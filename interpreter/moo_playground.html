<html>
<head>
	<script src="node_modules/moo/moo.js"></script>
</head>
<body>
<textarea id="editor" style="width: 500px; height: 300px">
binaryTreeHeight: tree >>
	tag #height.           // declare a tag, which can be used to attach attributes to objects

	// calculate height of all nodes
	for node in tree.nodes:
		node.#height: Math.max(node.left.#height | 0, node.right.#height | 0) + 1    // height based on heights of children

	=> tree.#height   // return height of root node

	// binary/unary op tests
	1-2             // all_ops
	1- 2            // all_ops
	1 -2            // unary
	1 - 2           // all_ops
	1*-2
	(1+2)-3
	a | !!b
	!!true          // unary
	! ! true        // all_ops
	foo(1 2)-3
	fn(1 2)-> - 3   // all_ops
	fn(1 2)-> -3    // unary
	fn(1 2)->-3     // all_ops
</textarea>
<br>
<button onclick="reset()"> go </button>
<button onclick="next()"> next token </button>
<br>
Moo Playground. Open Console. Press "go" to start parsing text. Press "next token" to get next token.

<script>
let lexer = null;
let editor = document.getElementById('editor');

function reset() {
	let input = editor.value;
	lexer.reset(input);
	console.log('------- lexer reset ------');
	console.log('input: ' + input);
}

function next() {
	console.log(lexer.next())
}

document.body.onload = () => {
	lexer = moo.compile({
		WS:      /[^\S\n]+/,
		comment: /\/\/.*?$/,
		number:  /[0-9]+/,
		string:  /"(?:\\["\\]|[^\n"\\])*"/,
		params: '>>',
		return: '=>',
		getReturn: '->',
		insertion: '<:',

		lparen:  '(',
		rparen:  ')',
		indent:  '{',
		dedent:  '}',
		lbracket: '[',
		rbracket: ']',

		// there are 3 unary ops: !, +, and -
		// unary ops can be after whitespace or any operator
		// in other words, they cannot be after a word, quote, "->", or any closed-brace (")","]","}")
		// unary operators can be followed by anything but whitespace
		// the first lookbehind checks for whitespace and operators, the second makes sure it isn't after a "->" operator
		// note that the unary_op regex is not for catching unary ops at the beginning of statements, which can have whitespace
		unary_op: /(?<=\s|[!+\-*/%<=>&|])(?<!\-\>)[!+-](?=\S)/,

		all_ops: ['!','+','-','**','*','/','%','<=','>=','<','>','==','=','!=','!==','&','|'],

		colon: ':',
		propAccess: /\.(?=\w|\#)/,
		period: '.',
		newline: { match: /\n/, lineBreaks: true },
		comma: ',',
		tag: /\#\w+/,
		identifier: { match: /\w+/ , type: moo.keywords({
				keyword: ['for', 'in', 'if', 'else', 'while', 'template', 'tag'],
			})},
	});

	reset();
}
</script>
</body>
</html>
