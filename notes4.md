### Random Syntax Stuff

* i forgot when I wrote these down, so some of this stuff might be outdated, but this was just syntax exploration

```js
set:
	10
	20
	30

(a, b, c) = set() // object deconstruction

sum: // a, b   <-- implicit inputs, generated by the IDE
	tag: 'hello'
	a+b

sum(
	a: 10,
	b: 20
)

Person:
	name: 'bob'


Student: Person
	occupation: 'student'

//------------------------------------------------------

outer:
	a: 10
	inner: // b
		a+b

Bob:
	name: 'bob'
	id: 21943
	age: 20

	mStudentId: studentId()
	onlineAlias: onlineAlias()



// -----------------------------------------

list
	reduce
		acc, fn
		for item in list
			acc.next: fn(acc, item)

mList: [1, 2, 3, 4]
mList.reduce(0, (acc, item, => acc+item) )
mList.reduce(0, acc+item ) // because acc and item are unbound in this scope, it's up to reduce's scope to provide values for them


Student: Person.with
	age: 22
	occupation: undefined

// ------------------------------------


stateVariable. = 0
for (reduceFn.calls):
	stateVariable++


// if we do standard imperative style

stateVariable. = 0
reduceFn:
	stateVariable++

// then we don't have control over how the reduceFn's interact and connect to eachother, versus if we do

stateVariable. = 0
for ( reduceFn.calls with nthChild(3n+1) ): // using css selector style
	stateVariable++

nthChildExample:
	for (n in naturalNumbers)
		if (3n+1 = index)
			-> true
	--> false
// right now will have overdefined anytime something is true
// we need some sort of syntax for defaults
// more discussion in this on the "Defaults" section

nthChild: {expression} // alternative syntax for arguments, it's really just creating a set and then extending it
	for (n in naturalNumbers)
		if (expression() = index) // as long as expression uses `n`, then it will be bound to the `n` in the for-loop
			-> true               // this is because of clone scoping
	--> false

```


### Arrow Operator to indicate Inputs

* instead of using the arrow operator to indicate outputs, maybe we can use it to indicate inputs

```js
foo: a, b, => // inputs/symbols
	x: "hello world"
	a+b // output

```

* recall that, back when `=>` was used for outputs, it forced us to group all our outputs onto one line/group at the end
* it actually makes more sense to use `=>` instead for inputs
* inputs are just variable names, so it's easy to group them all at the top, often on one line
* outputs can be long expressions, so forcing them on one line is annoying
* also, sometimes you might want some outputs in the middle, instead of all of them at the end

* a cool side effect of this is that, now the arrow operator works pretty much like in every other language

```js
// javascript code:
var myFn = (x, y) => x+y;
var squared = [1,2,3].map(x => x*x);

//arcana
myFn: x, y => x+y
squared: [1 2 3].map(x => x*x)
;
```

### Deeply Nested Outputs and State Variables

context: Carrying Out Deeply Nested Outputs

use state variables

```js
foo:
	x // a state variable
	a_bunch:
		of_nested:
			scopes:
				x := 20
```

### Branching II

context: Branching

recall that we were trying to find an easy to add a branch in the middle of a flow
the ugly way, that required an entire restructuring, was as follows

```js
var tablistcontainer = document.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot.getElementById("history-item-container")
tablistcontainer.appendChild(mytextarea)
var tablist = tablistcontainer.querySelectorAll(".website-title");
```

* we discussed how much easier this is in diagram-based languages
* where you can just draw connections

* text-based languages make it hard
* we could still sort of achieve this:

```js
// both values in the tuple have unbound `tablistcontainer`, which is then defined in the arguments module
// recall from the section "Implied Parenthesis" that indented blocks are implicitly treated as function arguments
(mytextarea.appendTo(tablistcontainer), tablistcontainer.querySelectorAll(".website-title"))
	tablistcontainer: document.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot.getElementById("history-item-container");
```

however, the above method still requires restructuring when we move the branch
alternatively, we can define some weird new syntax

```js
tablist: document
	.getElementById("history-app")
	.shadowRoot
	.getElementById("synced-devices")
	.shadowRoot
	.getElementById("synced-device-list")
	.children[0]
	.shadowRoot
	.getElementById("history-item-container") --> tablistcontainer
	.querySelectorAll(".website-title")

mytextarea.appendTo(tablistcontainer);
```

this still is a little ugly because we have to convert it to vertical style

```js
document.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot.getElementById("history-item-container")(--> tablistcontainer).querySelectorAll(".website-title")

mytextarea.appendTo(tablistcontainer);
```

or...?

```js
tablist: document
	.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot
	.getElementById("history-item-container") --> tablistcontainer
	.querySelectorAll(".website-title")

mytextarea.appendTo(tablistcontainer);
```

this^^ would still require some restructuring, but not as much


### <Nodes> Represent Ideas

* one of the benefits of Arcana is that, because everything is just a collection of properties, it is really easy to jot down rough ideas
* ideas are just collections of more ideas
* no structure, no form, no rules
* imperative langs impose too many rules to be able to do sketches

### Metaprogramming Thoughts III

context: Metaprogramming Thoughts I and II

* in fact, in "Facets" I talked about how programming is oftentimes about viewing a program from different perspectives
* there are many different perspectives we've discussed so far
	* the core code
	* preview view
	* version control
* metaprogramming and facets are very similar
* viewing a program from different perspectives
* arcana's flexible unrestricted syntax allows for ideas of any type or form to be written down
* metaprogramming allows these ideas to be interpreted and turned into actual programs

### IDE Smart Selection

* when you start selecting, it will try to guess what you are selecting, and make a generalization
  * eg if you are selecting variables that contain the word "elem", it will notice, and give you the option to select the rest
  * this is faster and more intuitive than trying to use regex

### Equality and State Variables

so after this whole singleton set shit

x: (a: 10, b: 20, 30)
x: 30 // true

it's comparing internal values

but what about if we are making objects
no internal value to compare
so compares references

y: (a: 10, b: 20)
z: (tag: 'hi', y)

y != z

sometimes we want to add tags or modify objects, but maintain equality
other times we want to create a new object, that we can modify independently of the old object

difference between modifying a node, and creating a new node

### Auto Binding - User Defined vs Dynamically Generated Properties

* objects can have two types of properties: user-defined and dynamically generated

```js
snippet = "aurora borealis!? At this time of year," ... "entirely within your kitchen!?"; // a long paragraph of words
HOVERTEXT_MAX_CHARS = 50; // maximum number of characters allowed in hover text

myObject = {
	title: "wordbank",
	description: "hashset of all words in a given snippet"
};
for (word in snippet.split(" ")) {
	myObject[word] = true
}

// an html element for the object
// `description` should be inherited from myObject
// however, imagine if `snippet` somehow contained the text "HOVERTEXT_MAX_CHARS"
// we don't want that to override 
myObjectDiv = myObject(
		hovertext: description.substring(0, HOVERTEXT_MAX_CHARS)
	);
```

* switch-style properties are dynamic, should they be excluded too?

### Sets in Sets

how do we interpret

```js
foo:
	x: 10
	(y: 20) // parenthesized expression

```

* does the parenthesized expression inside `foo` evaluate to an anonymous value?
* or does it evaluate to a property of foo?
* is there a difference?

* what about

```js
foo: (a, b, c), (d)
	e
	(f, g)
```


* how would we make a list of two lists?

### Overriding Anonymous Values

if we had something like

```js
sum:
	a + b

diff: sum(
	a-b
	); // this is passed into sum as an argument

// so how do we override sum's output?
```

### Clone Scopes and Time Complexity

* vishvanand brought up a good point about the time complexity of my weird scoping rules

```js
fn1: a+1

fn2: fn1(
	a+2
)
fn3: fn2(
	a+3
)
fn4: fn3(
	a+4
)

....

fnN: fnN-1(
	a+N
)
```

time complexity of this?

every time we add a value, it has to check it across all source scopes

perhaps we can memoize?
	every time we clone an object, memoize which arguments are unbound
	we can use the previous clone's memoization to figure it out
	only takes O(1)

what if overriding properties only changed last scope? but then do we still have access to source properties? I think so?

### The Comma Operater

* parenthesis is not used for sets

* have to use `{}` for sets
* each object indented block also counts as a set
* but if you have multiple parenthesis, they all combine

* can we do `x: (a: 'hello', b: 'world')` for inline objects?


* use spread operator to combine lists
* `combined: ...firstList, ...secondList`

* comma operator takes last precedence
* so `if __ else   if __ else` and other operators combine first

### Clone Scopes and Property Access

you can access parent scope properties?
	scope as inputs (find where previously talked about)
	inputs are local variables (talked about in onenote? maybe also in notes.mdown? maybe in implicit inputs section?)
	...
	but don't we already have this capability through inheritance? `Student: Person(...)`
	`foo1, foo2: foo1(...), foo3: foo2(...)`, `bar1, bar2: bar1(...), bar3: bar2(...)`, `foobar: ...?`
	no, I don't think you can implement our weird multiple-inheritance scoping with our inheritance model


scope as inputs
	when you call/clone, it actually re-defines the module in the argument scope? wrapping?
	that way, `foo()` defines it in an empty scope, and `foo(this)` wraps it in this scope

foo(a: 10, b: 20)

these are bound first? last?

source scope { argument scope { callee } }

argument scope { source scope { callee } }

* if bound first, then overrides scope binding
* if bound last, then property overriding doesn't work

scopes are just syntactic sugar for passing everything as an input

this way overriding is actually just overshadowing
also a consequence of being able to access parent properties


wait but overriding is different from overshadowing
in overriding, dependents are affected
in overshadowing, dependents are unaffected
if you are just overshadowing, then accessing parent dependents doesn't make sense does it?



metaprogrammings means that programs have to be able to be defined programatically (including the way scopes work)

so perhaps we need to be able to clone within a given scope, like `foo(this)` or `foo.applyScope(this)` was supposed to do

actually, we can define modules programmatically without it

```js
clone: obj =>
	clonedObj:
		for prop in obj.allProperties:
			(prop): clone(obj[prop])
;
```





perhaps we can programmatically define scopes using other methods...
override the accessor?
or can we achieve the same effect by defining our properties correctly?
how do streams work?
mixins? (if multiple inheritance, define a precedence order)




cloning isn't the same as creating an argument scope, or wrapping an argument scope
you are actually copying the original module, including the bindings
if you change an input, it affects the output, because the new output is bound to the new input
if you don't clone the bindings, then you aren't really creating new outputs


an alternative method would be to ask for outputs, which are dynamically created when needed
for example, if we had something like

```js
sum: a+b

myObject:
	a: 10, b: 20

out: myObject[sum] // dynamically call sum() from myObject's scope

```

it is like attaching an output
this is similar to functional, where everything is call-by-need
define a bunch of functions in global scope
each function has a single output
then when you need an output, you call the corresponding function, with the correct arguments


in Arcana, we are currently doing the opposite
we are providing the outputs beforehand, preparing them
in the background, it works using call-by-need though
but we are still explicitly declaring the outputs beforehand, even if we might not need them
kind of like APIs

this style allows us to "name" things, because names can be different based on context

```js
square: x => x*x

Person:
	BMI: weight/(square(height)) // weight in kg, height in m

Joe: Person
	weight: 50 // kg
	height: 1.6 // m

output: Joe.BMI

// makes a lot more sense than

output: (50/1.6*1.6) // call by need, functional style

```


man for some reason I just can't shake the feeling that clone scoping just makes sense
if argument and parameter names don't match, just pass them in
if parameter names are named correctly, then you don't need to
if everything in the world can be modeled in a graph of relationships, then we can't use a hierarchal model to name everything
the functional model, of putting functions in global scope and then attaching them to objects, makes sense
from the example in "Clone Scopes", it's not like `candy` should defined within a `Joe` or `Person` namespace, but `diabetic` clearly means the same thing in both contexts


we can define everything in global scope, which would be like functional style, and can accurately represent graph-like structures
it works like a whitelist: we explicitly declare bindings and arguments

when we use nested scopes, we are creating an approximation of the graph model, using a tree hierarchy
as we go further and further into nested scopes, more and more variables enter the scope
becomes a "blacklist" model, where we have a ton of variables in scope, and they are all included by default

note that it's still possible to create a graph-like structure using the tree model
we just start with the tree, and add back-pointers until we get the desired graph
in many cases this is the most intuitive way

however, in terms of _automatic_ bindings, the tree model just doesn't suffice
if we rely too much on the tree model, we will end up with code duplication, and trap ourselves with too many variables in scope

the tree model does two things:
	create a hierarchy
	set up a system of automatic bindings

we technically don't need the tree model to create a hierarchy
so the automatic bindings is the main reason
so clone scoping makes sense
if you don't want automatic bindings, don't use the tree model?

if we look inside an object cloned inside a tree hierarchy, and it says it's missing the `diabetic` value, even though `diabetic` is clearly defined in the tree...


perhaps this is more based on the IDE
allow us to write a function in global scope while in local scope
like a `create new global variable` context menu option or something


what if we wanted `Joe` to buy a candy for a different person?
then `Joe.diabetic` shouldn't affect the candy
but the candy also shouldn't be created in Joe either right?
maybe created in a Vending Machine or something
but then again, Joe's personal candy would be created in the Vending Machine too
the request for the candy is created in Joe, with Joe's personal dietary restrictions
but then again, the request for his friend's candy is also created in Joe...
we're just changing layers of abstraction, but we have the same problem



creating things in other scopes breaks encapsulation
so perhaps calling from other scopes, `fn.apply(otherObject)`, doesn't make much sense
note that this would be using flag-watcher model, asking `otherObject` to create the object for us
so it could return undefined if we want


should we allow automatic bindings across arbitrary structures, not just tree structures?
allow inheritances along a graph structure?
we already kind of have this with overriding
this is a different sort of inheritance?
`foo: bar()` vs `foo: bar: ...`
first example, foo is bar's child, foo inherits from bar
second example, bar inherits from foo

I realize now that i've been mixing up scoping and inheritance
discussed in the later section "Scopes vs Inheritance"

### Advanced Useless Machine II

```js
lastReset = now() // time of last reset switch

function resetTimer() {
	lastReset = now()
	setTimeout(_ -> 
		if (now() - lastReset >= 20) // if it wasn't reset during the timeout, then close the box
			closebox()
	, 20)
}

// called when switch is turned on
function onswitch(index) {
	if (box.closed)
		openbox()

	closeSwitch(index)
	resetTimer()
}
```


```js
box:
	open, closed // states
	state: if (current_time .within(10).after (last_opened) ) open else closed

last_opened: Math.max(...switches.map(x => x.on_opened.lastCall)) // when the most recent switch was opened
_switch:
	on_opened: do // note that i'm assuming multiple calls are queued up, like in javascript
		close()
;
```


```js
simple_useless_machine:
	box:
		open, close
	switch:
		close, // action for closing the switch (implementation hidden)
		on_opened:
			box.open()
			close()
			box.close()

advanced_useless_machine: simple_useless_machine (

	@metaprogramming(foo)
	for switch in switches:
		when switch.opened:
			switch.close()

	foo:
		queue:

			
		box:

		switch:
			on_closed:
			on_opened:

);
```


### State Variables Syntax Brainstorm

* use `:=` to re-define a state variable?

```js
foo:
	counter := 10 // initial declaration
	for keypresses:
		counter++
```

* note that the initial declaration uses the re-definition operator `:=`
* maybe we can consider it a re-definition, and that `counter` is an implicit symbol (because not declared in scope)?
* nah, because if it already is in scope, we want to shadow it with our own `counter` variable...

* also, remember that we can only re-assign once per scope?








nested scopes are allowed in functional

```js
function createCounter() {
	x = 0;
  return function () {
  	return x++;
  }
}

function fibonacci(n) {
	// a: last fib number
	// b: second to last fib number
	// i: index
	return (function helper(a, b, i) {
		return i < n ? helper(a+b, a, i+1) : a+b
	})(0,1,0)
}
```


how does metaprogramming work in javascript? can you even create functions with local variables?
how would I make the `createCounter` function programmatically?






### Scopes vs Inheritance

scoping and inheritance both involve dynamic binding

```js
//inheritance
Person: name, age, occupation
	greeting: "hi I'm " + name + ", I'm a " + occupation
Student: Person
	occupation: "student"
	studentId: name+major+graduationYear

// scoping
Person2:
	name, age, occupation
	greeting: "hi I'm " + name + ", I'm a " + occupation
	Student2:
		occupation: "student"
		studentId: name+major+graduationYear
```

* inheritance is uses a tree structure (every child can only have one parent)
* scoping traditionally uses a tree structure...	
	* but our clone scoping model uses a weirder structure

* property access is traditionally different
* `Student.age` exists, `Student2.age` doesn't exist

* inheritance overrides variables, scoping shadows variables
* inheritance can affect parent properties, scoping can't
	* eg `greeting` is affected in `Student`, but not `Student2`
	* `greeting` is also not accessible from `Student2`

* `Student` is a global variable
* `Student2` is not

### Scopes as Namespaces

* notice that in the previous section "Scopes vs Inheritance", `Student` was a global variable while `Student2` was not
* perhaps scopes are just used to separate variables into namespaces
* having everything as a global variable will just make names super messy

* but namespaces are like pointers: `Books->Fiction->Fantasy->HarryPotter`
* but pointers don't have to form tree structures
* what's wrong with `Books->YoungAdult->HarryPotter`

* namespaces and variables should form a graph structure
* there are multiple routes to each variable
* every program starts at a certain namespace
* and can move around, navigate through the namespace graph
* in the above example, the program is starting at the `Books` namespace

* Cono (common knowledge) is the entire graph of all human knowledge
* every program just starts at a node in the graph, and works it's way around

* but if namespaces form a graph structure, then how does scoping work?
* usually, scopes form tree structures, and the number of variables in scope increases as you get into deeper scopes

* but in fact, if you have feedback in your scopes

```js
foo:
	bar:
		zed: foo
```

* we can "expand" `zed: foo` infinitely

```js
foo:
  bar:
    zed:
      bar:
        zed:
          bar:
            zed:
              ...
_
```

* but then, does `zed` see all variables inside `bar`? does `bar` see all variables inside `zed`?

* tree-structured hierarchal scoping is just an approximation
* this relates back to the section "Scope as a Search Function"
* we could feasibly have an AI do dynamic scoping for us, and recommend to us bindings and such
* but for now, maybe hierarchal scoping is the next best thing we have

### Cloning and Feedback

* note that it's possible to create an infinite cloning loop

		foo: foo()

* this is possible in any language though

		function fn() { fn(); }

* this is different from reference feedback

		foo: foo

* because reference feedback is structural, doesn't involve creating anything new

### Cloning - The Dynamic Component

* in the previous section, "Clone Feedback", I had a huge realization

* cloning is the only "dynamic" component of the language

* everything else is based on references and structures
* but cloning actually creates something new, creates new information
* that's why feedback is only an issue when it involves cloning
* if there's no cloning, then it's a purely structural feedback, and can evaluate in finite time

* how does this fit into our previous conclusion, about how feedback is about evaluation models
	* see the section "Feedback - Evaluation Models/Systems"
* I guess you could consider `foo: foo()` a structure, if you consider the cloning process a "module"
* but something still has to evaluate it
* something has to generate new information
* I guess in my previous conclusion, I was ignoring the fact that evaluation models need to be implemented in Arcana too

* if you think about it, the state machine of a Turing machine is a finite structure as well
* so it's really just the evaluation of that state machine that can cause infinite behavior
* the only thing that allows programs to halt is the "end condition" of the Turing machine
* but because our language is persistent, there is no "end condition", everything is being continuously evaluated

### Scoping Feedback

* is it possible to create feedback using our dynamic scoping rules?

* with clone scoping

```js
foo:
	x
	bar:
		x: 10
		zed: foo() // implicit scope inheritance

foo:
	bar: foo.withScope(this) // explicit scope passing
;
```

* this isn't so much of a dynamic scoping problem, as it is a clone feedback problem
* we are actually creating new instances of `foo` every time, (along with a new scope), so there actually is no feedback in the scopes

* however, if we factor in state variables

```js
foo:
	x
	bar:
		x: 10

onClick:
	foo.bar.zed := foo.withScope(this)
;
```

* does this introduce feedback?
* I mean it seems totally plausible that we could create a feedback system with dynamic scopes
* involving dynamic bindings that go in a loop
* but is that really preventable? Or is that something the programmer just has to be wary of

### Sub-Properties

* objects can be properties (see section "Objects as Property Keys II")
* that means property keys can have properties!
* tags in tags in tags! (yo dawg I heard you like tags...)

* this can be useful for things like state variables
* if you create a state variable indexed by time:

```
onKeyPress(event):
	stateVar[event.time] := event.key
```

* `event.time` resolves to a number, that can be used to order all states of the state variable
* however, let's say somebody messes with the state variable:

```
for (i from 0 to 10):
	stateVar[i] := "hehe"
```

* these new states have a numerical index as well
* however, they don't actually represent "time"
* our system can detect that the index types don't match because `event.time` actually has the `type: time` tag

```
event.time:
	1530358922792 // example time (milliseconds since 1970)
	type: "time"
```

* oftentimes the index or property name doesn't give us enough information
* we can use sub-properties to learn more

### Property Access for Mixed Modules

property access for "mixed" modules?
does it return properties of the module, or the outputs?
or are they combined? and if so, which takes precedence?
	it feels kinda similar to inheritance
	but it isn't the same

maybe inherits the same way as state variables?
have a `self` or `this` variable that references the latest value?
* kinda like how javascript uses `this` inside objects/classes for object properties
	* `this.x = 10` sets the object member, `x = 10` sets a local variable
* we can do something similar for state variables
	* `{x: 10 {x : 20} }` just shadows the variables, they don't affect eachother
	* `{ this.x: 10 { this.x: 20 } }` now the variables affect eachother, they refer to the same `x` variable


two ways of dealing with "mixed" modules
	1. a special operator to access values
	2. inheritance (output inherits module properties, or vice versa)
	3. go back to transformations model

the transformations model kinda makes sense:
	take a piece of the network graph
	clone it
	and then return only the last nodes in the cloned graph, the "output nodes"
	we don't want to just clone the last node, but we also don't want to return the entire graph

let's try the inheritance model...
if the hanging value is supposed to represent the "output" of the module, then it should take precedence for inheritance

so hanging values inherit all properties from the module?
but recall that hanging values are just properties without names
but if hanging values inherit properties from the module, then shouldn't every other property do the same?
in diagram-based syntax, we had a special accessor for accessing the entire object

perhaps we don't need transformations
in the diagram-syntax, every variable pointed to an object, that's it
just use accessor pattern
every node represents a bunch of references
a group of transformations
you clone the entire group
and the next part pulls out whatever it needs

### Back to Regular Nodes and Modules

* perhaps we should just go back to the old model of just properties
* no return statements or default outputs
* cloning just clones the entire module, and returns the entire module
* basically, the idea of "Nodes" that we established way back in the section "Node datatype"
	* and in our diagram syntax

* how would this work with `map`?
* imagine `map()` with only properties (no returns, unbound variables or hanging values)
* you give `map` a module to create for each item, `fn`
* for each list item, `map` clones `fn` and calls it with the item: `fn(item)`
* from each of these clones, `map` pulls out the result of the module, `fn(item).result`

* so it would look something like this:

```js
nums: [1 3 4]
square: x => result: x*x
// note: a wrapper to make `square` compatible with `map`
squareMap: item => result: square(x: item).result // basically just changes the property names to ones recognized by `map`

list:
	map: fn =>
		mapResult: []
		for list: item, index =>
			mapResult[index]: fn(item: item).result

nums.map(squareMap).mapResult = [1 9 16]
```

* this works fine
* it only looks ugly because we have these kinda arbitrary names, `x`, `item`, `result` and `mapResult` that we have to keep track of
* we have to create the intermediate function `squareMap` just to make `square` compatible with `map`

* anonymous keys and values takes care of this annoyance
* basically, just remove the property names (just like we can do in the diagram-based syntax)
* we are not introducing any new mechanics, we are just changing the names of properties

```js
nums: [1 3 4]
square: x => x*x

list:
	map: fn =>
		mapResult: []
		for list: item, index =>
			(mapResult[index]): fn(item) // notice the object deconstruction syntax used to pull the anonymous value out of fn(item)
		mapResult // output mapResult as an anonymous value

nums.map(squareMap)... = [1 9 16]; // notice the anonymous value access, using the spread operator
```

* notice that we don't need the wrapper function `squareMap` anymore

the only way to pull hanging values out is to use unbound symbols
many ways to do so:
	deconstruction, like `(a, b): mNode`
	[] or . operator without a name (so something like `mNode[]`, or `mNode.`)
	spread operator, eg `fn(mNode...)` or `mNode... = (1, 2)`

* it's interesting because this all makes a lot more sense in diagrams
* much more intuitive
* see "Nodes.one" for more
* and it's basically how my diagram-based syntax has worked since the beginning
* so i think the text-based language confused me a little bit
* we are just so used to the idea of "functions"
	* you call a function, it runs the body, and then returns a result
* it's weird to imagine a language where calling a function returns the entire function
* but that's exactly how nodes work
* and using value access everywhere is just something you have to get used to, I guess

### The Map Function and the Evolution of Nodes (so far)

note that, one of the MAJOR examples I was considering for the past like 2 months or so is the `map` example
(even though I barely mention it in the notes)
It was one of the main reasons why I thought transformations made sense
because it felt ugly to use accessor pattern directly, like `map(fn(...).result)`
	in fact, I realized that accessor pattern doesn't even work here, because `map` would be cloning `result`, not the module
or to have `map` have some specified property that it pulled from, eg `map: fn => result: fn(item).result, ...`
so it seemed like `map` needed to:
	1. be given a module
	2. call the module with the list item as an argument
	3. use the result from the module, _not the module itself_
that last part was important, because without transformations, it would return the module itself
	* eg, if you wanted to square a list of numbers, `list.map(square)` would return a list of `square` modules, not a list of numbers
this is why transformations made sense
	when cloning the module, it automatically returned the result, not the module itself
however, I had to come up with special rules about cloning transformations
	cloning would override the intermediate scope, not the result
and I realized that these special rules broke associativity
	* see section "Cloning and The Associative Property"
at the same time, I was finalizing my ideas about unbound keys and hanging values
to solve the associativity problem, I tried to create a concept of "mixed modules"
	* see section "Mixed Modules"
* modules could be viewed as both a module or a value
* modules represented a history of values and operations
* however, this ultimately created conflicts, especially when it came to accessing properties
	* should property access take from the module or the value? or both?
	* should the value inherit properties from the module?
* I realized I had to go back to the diagram syntax, go back to thinking about nodes as just nodes in a graph
* cloning just clones a section of the graph
* `map` has to be given which section of the graph to clone
* it's up to `map` to handle the result
	* it could pull out a designated property, like `result` or something
	* but it could also just return the entire cloned module
	* and there's nothing the user can do about it
	* if `list.map(square)` returns a list of `square` modules, not a list of numbers, then that's just how `map` is implemented
* makes the most sense for `map` to extract a value from the module
* luckily, we can leverage hanging values so we don't have to use a designated name like `result`
* note that this means, that if we want `map` to return the entire cloned module, we have to specify that in our given function
	* eg: `square: x => result: x*x, this`
	* notice that the hanging value is `this`, which refers to the entire `square` module, so that's what `map` will return

### Default Outputs

* before, I considered the idea that modules with no outputs should by default "return" the entire module
	* see section "Transformations vs Objects"
	* I talked about how "regular modules are a special kind of transformation, whose output is the module itself"
* this also sort of made sense with the idea of mixed modules
* however, in the context of nodes, this doesn't make sense anymore
* outputs are just hanging values, properties with no name
* if there are no such values, then there are no "outputs"
* makes a lot of sense with object deconstruction

```js
(output1, output2):
	a: 10
	b: 20
	a+b
```

* in the above example, `output2` is undefined
* likewise:

```js
(output1):
	a: 10
	b: 20
```

* in this example, `output1` should be undefined
* wouldn't make sense for `output1` to suddenly store the entire object

### Ordered Lists and Indexed Output Access

* I think if we want to access hanging values individually
* we should use numerical indices
* but then our sets are basically arrays now... :/
* Nylo treats it as ordered lists as well

### Mixed Nodes Revisited

everything is a mixed node
up to the operators how to treat it
we can make it so inputs to functions automatically spread
because thats how it looks in diagrams
we can add an operator if we want to access 

```js
sum: a, b => a+b
Person: name, age, id =>
;
x: sum(10, 20)
Bob: Person(name: "Bob", age: 30, id: 0x31da3);
```

* notice that if you wanted to use `x` stores an object, `( a: 10, b: 20, 30 )`
* if you wanted to get the value `30`, you would have to use `...x`
* or we could have declared `x: ...sum(10,20)`
* thing is, in this case, we would never really ever use `x` as an object
* so we would either have to use `...x` everywhere, or declare it with `...sum(10,20)`
* in fact, for most functions like `sum`, things that have an "output", you would rarely ever use it as an object

* the opposite is true for objects
* while `Bob` technically has an output value of `()` (an empty set), we would rarely ever use that

* so perhaps we can treat objects different depending on whether or not they have outputs
* treat them as either a "transformation" or an "object"
* because rarely are they used as both

* so whenever you use `x`, it pulls out the values
* best understood through diagrams
* usage vs cloning
* should be able to clone functions
* 

* or maybe () is like a general purpose "call", works differently for objects vs functions
* there is an explicit operator for cloning
* and an explicit operator for extraction (spread operator `...`)

* foo: sum() actually uses deconstruction
* if you want to be explicit, and return an object, there's an operator for that
* `...foo: sum()`
* wait...or you can just use cloning for that




* note that this is whether or not they have _declared_ outputs
* for something like this

```js
foo: cond =>
	if (cond): 10
```

* `foo` technically has no outputs if `cond` is false
* however, because we are declaring outputs, we are viewing `foo` as a function, not a module


Cloning should work the same
Usage could be different




### Diagram vs Text Based Syntax

* I realized a lot of the problems I was having was because it's hard to translate my diagram syntax to text
* a lot of the stuff giving me trouble are things that work pretty intuitively in the diagram syntax

* for example, in diagrams, it's easy to see whether or not a variable refers to the module itself, or an output
	* just look at if the variable name is at the top of the module, or at the end of an output

* we can also easily pick specific outputs, without numerical indices, using something like

```
    ___________
   |____foo____|
     ' | ' | |
```

* this extracts the 2nd, 4th, and 5th output

### Internal Unwrapping

* why can't we use the `internal_value` model we explored for numbers and `sum`?

```js
sum: (a b) => internal_value: a.internal_value + b.internal_value
```

* this makes it so we can take results directly and sum them again, like `sum(sum(1,2), sum(3,4))`
* if we use unbound keys and values, we won't need the arbitrary `internal_value` keyword

```js
sum: (a b) => ...a + ...b
;
```

* so now we can use `sum` like normal
* however, writing the `sum` function is still weird
* we have to keep in mind this unwrapping
* for example, if we wanted to write a function that multiplies two matrices

```js
matprod: (a b) =>
	Matrix
		map a.rows: row =>
			map b.cols: col =>
				dot(row, col)
;

x: Matrix(...);
xx: matprod(x,x); // this works (but doesn't return a Matrix, rather, an object containing a Matrix)
xxx: matprod( matprod(x, x) , matprod(x, x) ); // this won't work
```

* we can't use the results of `matprod` as arguments for another call to `matprod`
* we have to remember to use `...a` and `...b` if I want to support this recursive behavior

```js
Matrix.multiply: (a b) =>
	Matrix
		map ...a.rows: row =>
			map ...b.cols: col =>
				dot(row, col)
;
```

* so this unwrapping behavior, we can either do it outside the function, or inside the function
* but it needs to happen somewhere


* unless we make it the default behavior for modules with hanging values?
* a hanging value is like a return statement
* when you clone the function, it returns the hanging value as output?

### Object Deconstruction

object deconstruction is just key-value auto-binding!
`firstVal: foo()`, `firstVal, secondVal: foo()`

maybe property access should access the original object properties, not properties of the values
`myfunction(foo(10,20).bar)` means we don't want to auto-bind key-values anymore
but this only works for direct clone access
if we do `x: foo(10,20), x.bar`, `x` is already the deconstructed first argument

wait but if things get autodeconstructed, `foo(x(), y())` what if `x()` has multiple outputs...shouldn't it treat it as a set? or an object?
same with `foo: x(), y()`, this shouldn't be equivalent to `foo: ...x(), ...y()` right?

### Currying and Returns

* so I was talking about veggero about cloning and currying
* because recall that I thought calling broke associativity (see section "Cloning and The Associative Property")
* aka `x = x() = x()()`
* however, Nylo supports currying, even though it seems to have function calling
* so I talked with veggero about it
* and he seemed to have confirmed my suspicions
* basically, the way Nylo works, is that even though it has the concept of functions, it waits for it to be "complete" before return the outputs
* for example, take `sum: a, b -> a+b`
* `sum(10)` would return a clone of the sum function
* but `sum(10)(20)` would return the output, `30`

* the problem is, a distributed dataflow language like Arcana, shouldn't have the concept of "incomplete" vs "complete" functions
* if we are extracting the output of a node, it doesn't matter whether its incomplete or complete
* an output is an output
* you never know when an input might go `undefined` temporarily
* that shouldn't suddenly make the function become "incomplete" and break everything after it

### Imperative Langs and Multiple Outputs

* note that, in normal imperative langs:
	* if you return one item, its just the item
	* if you return multiple, it has to be wrapped in a set
* eg `() => 10` vs `() => [10, 20]`
* so even in imperative langs, there's a distinction between single and multiple return
* thought that's sort of because imperative langs are only used to one output
* but maybe one output is just so much more common than any other case
* and text-based syntax works best with one output

### Function vs Class - Dynamic Evaluation and Forced Coercion

* maybe we can combine the ideas of nylo and arcana
* it makes sense to kinda differentiate between classes and functions
* but at the same time, they should have the same structure (set of keys + values)
* in nylo, you specify a function using `->`
	* in nylo, there are some other differences between a function/class, but that's not too relevant here
* instead, maybe we can have dynamic evaluation of function vs class
* by default, if there is only one static output, it is a function, otherwise its a class
* you can force it to be evaluated as a class using `{}`
	* groups it into one object
* you can force it to be evaluated as a function using `...`
	* extracts and spreads the values

* so to defining a function would look like:

```js
{sum}: a b => a+b
;
```

* which basically is
	1. creating a module, with a single output
	2. binding the name to the module, not the output

* while this makes it a little uglier, and means we have to use special notation to define functions
* it's already common in languages to have different syntax for function vs class
* and we had to do that in nylo's version anyways, using the arrow operator for functions

* it also makes sense if you think about object destructuring
* recall that something like this

```js
a, b, c : (x: 10, y: 20, x+y, x*y, x/y)
```

* binds the values of the right hand side to `a`, `b`, and `c`
* it follows that this:

```js
a: (x: 10, y: 20, x+y, x*y, x/y)
```

* is just binding the first value

### Function/Class Syntax Exploration

* exploring some other syntaxes for defining functions:

```js
{sum}: a b => a+b // looks like the modules in diagram language

sum(): a b => a+b // looks like imperative function declarations

sum...: a b => a+b // sorta makes sense b/c the spread operator is on the other side, so instead of deconstruction, its like object _construction_

;
```

* what about when passing functions?

```js
list.map(a b => a+b)
;
```

* hmm, now it's being evaluated as a function, so won't it end up passing it's values to `map`, instead of the entire function?
* you would have to do `list.map({a b => a+b})`

* the thing is, there is no reason to define a module unless you want it treated as a module
* if we just wanted to pass the values to `map`, we could have just done `list.map(a+b)`
* even if we wanted some intermediate variables, we could have defined them in the outer scope
	* eg: `c: a+b, list.map(c)`

* same with definitions, there is no reason we'd define a module from scratch unless we wanted it treated as a module

```js
sum: a b => a+b
;
```

* in the above example, it get's evaluated as a function, so it passes its values to `sum`
* but then we could have just done `sum: a+b`

* the only time we might want it evaluated as a function is if we were cloning a function

```js
add10: a => sum(b: 10)
;
```

so it seems like it really does all come back to cloning vs calling after all

### Different Syntax for Calling vs Cloning

* actually the solution seems simple enough
* just use different syntax for cloning vs calling!
* `foo(...)` for calling, and `foo{...}` for cloning
* remember that calling is just shorthand for cloning + spreading (`...foo`)
* but now, we can actually use `foo()` as shorthand for spreading, `...foo`

* this also makes sense for bracketed expressions
	* discussed previously in section "Singleton Sets"
* in `(3+1)`, we are "calling" the blank scope with `4` as an argument, so `4` gets returned
* if we want to create a set with `4` in it, we have to clone the blank scope, like `{3+1}`

* note that operators, like `+` and `==`, are shorthand for function _calls_, not cloning

* notice that, as discussed in the previous section "Function/Class Syntax Exploration", there's still not much point to using parenthesis when calling/cloning
* eg `foo(10, (a b => a+b))`
* because it just evaluates to the values
* you have to explicitely create it as a module if you want one, `foo(10, {a b => a+b})`

* I have honestly no idea why it took me so long to come up with this idea
* I guess I was just so obsessed with the idea that calling and cloning were the same thing
* and to be able to use the `()` bracket for everything

### Implicit Parenthesis III

* so now that we have different brackets for calling and cloning, what does that mean for indentation and implicit parenthesis?
* makes the most sense for the implicit bracket to be `{}`

```js
Student: Person
	occupation: "student"

// is the same as

Student: Person {
	occupation: "student"
}
_
```

* note that the first line is still interpreted as a value or "expression"
* because no indentation yet

but then how would we do implicit brackets for calls?

```js
// this doesn't work because it's cloning sum{}
x: sum
	a: 10, b: 20

// this doesn't work either, it's returning the output of sum, and cloning that
x: sum()
	a: 10, b: 20

// this works (because the implied brackets takes precedence over the spread operator), but it's ugly
x: ...sum
	a: 10, b: 20
```

* note that we could also switch implied brackets to be () instead of {}
* because there's no reason to clone without arguments,
	* empty braces `{}` can be used for capturing the subsequent indented block as arguments

### Calling and Map

* note that, now, if you pass an object to `map`, it will "call" the object, and return the output (aka nothing, b/c objects have no output)

* this actually makes sense
* `list.map` takes a function
* so if you give it an object, with no return
* makes sense that it will extract nothing and return nothing
* likewise, if you have multiple outputs, it will append all of them
* if you want the multiple outputs to be appended as a set, you have to output the object itself
	* just like how in regular imperative langs, you have to wrap the outputs in a set

### Dynamic Scoping vs Inheritance - App Creation Example

* if we were making an app, where should we store the data?
* we could make it a web-app, which automatically makes it session based
* we could make it a user-app, which makes it persistent
* depending on where we "attach" the data, determines its lifetime
* this is sorta like dynamic scoping
* if we declare the app in the "web" context, it inherits all the methods and properties of web apps
* if we declare it in "user" context, it inherits all methods and properties of user apps
* though we could do it a more conventional way using inheritance
* just extend the prototype `WebApp` or `UserApp`, and it naturally comes with all the appropriate methods/properties
* so what's the difference?





### Summary of Ideas Explored for Nodes

ideas explored so far:
	returns and arrow operator
	dynamic interpretation of function vs class
		based on usage (mixed module)
		based on number of outputs
	different syntax for function vs class
		use {} to force evaluation as a class
		use ... to force evaluation as a function
	different syntax for calling vs cloning

### Values are Lists

* I decided to treat hanging values as list values, not set values, like how Nylo does it
* this means that hanging values are ordered now
* one benefit is we can now reference values by index
* another benefit is we can use `()` to define lists
* one last, huge benefit, is we can now use `[]` for defining modules, and get rid of the ugly `{}` notation
	* jk we can't actually do that
	* because then, is `foo[x: 10]` cloning `foo`, or accessing a property of `foo` (whose key is `x: 10`)?* 

* in addition, index makes a bit more sense now
* if we do `[10, 20, 30]`, it works like python's multidimensional array access, and is equivalent to `[10][20][30]`
* notice that this wouldn't be possible if it were unordered* 

* we will just use `key: true` for set values, like in every other language (python, javascript)

* maybe we can also use periods for creating sets
* `foo: a. b. c.` is the same as `foo: ( a: true, b: true, c: true )`

### Lists and Statements

* now that hanging values are ordered...
* this actually works well with state variables now
* because we can insert ordered statements directly into the object, and treat them as list values
	* eg `x++` and `y := 20` and `foo.push('hi')`
* note that most statements and variable modifications have no returned output
* so even though they're treated as list values and "executed", they won't show up in the actual output

### Square Brackets without Target

* notice that `()`, `{}`, and `[]` are all operators that
	1. have a target object
	2. take an object as input (source object)
* which is why they all use brackets (whereas other operators like `+` don't need it)
* however, remember that the idea of using `(x: 10)` without a target object is kinda like calling/extending a "blank slate"
	* as mentioned in the section "Implied Parenthesis" and "Implied Parenthesis II"
* thus, shouldn't `[]` without a target object also do something?

* in fact, it makes sense for it to do something
* access properties in the current scope!
* obviously we can access properties just using their name
	* eg `foo: a+b` will access properties `a` and `b` in the scope
* but if we want to use dynamic keys or object keys, we can use `[]`
	* eg `foo[a+b]` or `foo[type: number]`
* note that we can also do `this[a+b]`

* but does `this` and `[]` use the scope or the current object, as the source?
* this will affect whether or not it can access parent scopes or inherited properties




### Square Brackets without Source

* perhaps `[]` should be for keys

source-less []: retrieve values without properties? retrieve all keys?




### Clone Scopes

* because we have different syntax for cloning vs calling, we can actually leverage this for clone scopes
* cloning inherits the current scope, calling does not
* this actually makes a lot of sense, because inheriting scope doesn't really make sense for calling, but it does for cloning

* also, if we want to call and inherit scope, just do `fn{}(...)`

* also, if we want to clone without inheriting scope, just do `{fn(...)}`

* this gets kinda ugly with indentation

```js
// how to call with indentation?

// cloning without inheriting scope (blank-slate cloning):

foo: { bar(
	x: 10
)}
_
```

maybe we can use capture blocks (discussed later in section "Capture Blocks")

### Calling and Cloning - Edge Cases

* so how does object destructuring work now?

```js
a: 10 // is a equal to {10} or 10?
b: 
	10 // is b equal to {10} or 10?
c: 10
	20 // what is c?
d: (x: 10) // what happens here? is d = {x : 10}? is the line evaluate, and since no outputs, d = null? or a syntax error?

a, b: {10} // what happens here? does it get destructured into a: 10, b: null?
a, b: 10 // what happens here? does 10 somehow get destructured?

;
```

### Capture Blocks

* the idea of capture blocks, is to "capture" the next indented block as arguments
* for example, something like 

```js
foo: ()
	x: 10
	x*x + 30
```

* would be shorthand for this:

```js
foo: (
	x: 10
	x*x + 30
)
```

* let's us get rid of those pesky dangling closing brackets
* you could do the same for square brackets:

```js
[]
	x: 10
```

* and even though you don't need it for objects (because of implied brackets), it makes nested objects look better

```js
foo:
	{}
		x: 10
		y: 20
	{}
		bar: 'hello'
```

* problem is, it doesn't quite work for function calls

```js
foo: sum() // looks like capturing block, but it actually is extracting sum() and then cloning the result
	a: 10
	b: 20
```

* perhaps we can make this^^  work by having capture blocks take priority
* aka, first the parenthesis+capture block is evaluated, and then used as a call to `sum`
* so if we wanted to do the reverse, and first call `sum` and then treat the block as cloning, we would have to do

```js
foo: sum(){}
	tag: "this is attached to the result of sum()"
```

* we have the same confusion for brackets

```js
foo: sum[]
	x: 10
```

* is this^^ retrieving the keys of sum (which is what `sum[]` does), and then cloning them?
* or is it a capture block for an object key?

* honestly, the original order made more sense, `sum()` already looks like it's calling `sum` with no arguments
* to invert the order for capture blocks is unintuitive

### Capture Blocks II

* alternatively, we can also have special notation for capture blocks

```js
foo(...) // nice but uses a lot of characters
	x: 10
foo( ) // whitespace matters? but only for empty braces?
	x: 10
foo(_) // ugly, 
	x: 10
foo(): // doesn't this conflict with dynamic keys? shouldn't `:` be reserved for binding?
	x: 10
foo(): // ellipses character looks more compact than triple dot. Automatic conversion by IDE? But then you can't use normal text editors
	x: 10 // oerperhaps make it so ... and  are both recognized the same

```

* I think the ellipses looks the best actually
* so here is what capture blocks will look like

```js
()
	10, 20, 30

[]
	x: 10

foo:
	{}
		x: 10
		y: 20
	{} // note that we can still use this, or even omit it entirely, due to rules for cloning and implicit braces
		bar: 'hello'
```

* maybe we can even do stuff like

```js
foo: mylist.reduce().apply(x, y => x/y) + 10
	x: prev.x+1
	y: prev.x*prev.y
```

* capture block can be used inside expression
* obviously, only one allowed per line
* or maybe we can have multiple, which correspond to multiple indented blocks separated by empty lines

### Brackets Trinity

* the three brackets of power:

* [] is for keys
* () is for values
* {} is for nodes/groups

* it's not actually that perfectly symmetric but close enough
* I kinda came up with a language that only uses one bracket
* in the next section, "1Bracket: an experimental language"

### 1Bracket: an experimental language

* only one bracket: `()`
* all properties have to have names (so there's actually no difference between calling and cloning)
* if a module is given a value as an argument, treats it as a key, returns corresponding value
* if a module is given properties as an argument, clones module while overriding given properties
* if a module is given both values and properties, then it clones the module, and returns the corresponding values

* note that this allows us to use implied parenthesis for everything (no need for capture blocks)
* however, we will also probably have a lot of arbitrary names like `result` and `mapResult`
	* see section "Back to Regular Nodes and Modules" for why

### `For` Keyword

* so Nylo has the `for` keyword for map operations, which is pretty nice
* I've been using the keywords `reduce`, `map`, and `filter`, but those are kinda ugly terms
	* I'm actually not sure how Nylo handles reductions actually
* recall that in my diagram language, I had the "fan-out" syntax for reduction and map
* I think I can work that into the `for` syntax

```js
list: { 1 2 3 4 5 }
result: for item in list:
	item*item // any values are appended to the final list, like a map operation
	if (item % 2) 'x'+item // we can use conditionals for filter operations
	sum: item+prev.sum // use properties to do reductions. `prev` refers to previous states
	product: item*prev.sum // this syntax makes it easy to define reductions that pass multiple variables

result = { 1 4 'x2' 9 16 'x4' 25 }
```

### Indented Expression

* normally indented blocks are evaluated as object/nodes
* because of implied `{}`
* but sometimes you just want to move an expression to another line
* you can actually do something like this

```js
foo:
	list => ...
		for x in list:
			x*x
```
* without the `...`, the block under the `=>` would be viewed as an object, not an expression
	* the implied `{}` would make it look like `list => { for x in list: x*x }`
* but with the `...`, it now looks like `list => ...{ for x in list: x*x }`
* turning the indented block into an expression
* and we didn't even need to introduce new syntax!

### Dynamic Keys vs Conditionals

* be careful of the difference between dynamic keys and conditionals

```js
foo:
	(cond): 10 // dynamic key
	if (cond): 10 // conditional

```

* the first evaluates to a property, with a dynamic key
* if `cond` evaluates to `true`, then it becomes `true: 10`
* on the other hand, if conditionals evaluate to true, the inner values spread into the outer block
* if `cond` evalutes to `true`, then `foo` evaluates to `{10}`

### Matchers

* the idea behind matcher functions
* 	you can provide functions as a key
		if the function returns true when passed the accessor input, then it accesses the property
	strings and ints are actually functions that return true when passed themselves?
* matchers have a conditonal, and a value
	* if the key passes the conditional, then the value is returned
* they are like dynamic properties
* for example, we could create an object that looks like `{ a b c a b c a b c... }` from the outside
* useful for streams

syntax exploration

```js
multipleOfThree: x -> x % 3 == 0

foo:
	(multipleOfThree): 'a'
	(!multipleOfThree):
		key % 3 + 1 == 0: 'b'
		else: 'c'

match key -> if even(key): key*2

match if even(key): key*2 // by default, the match function provides a `key` variable

[key]: if even(key) key*2 // alternative syntax?

```

### Dynamic Class/Function Revisited

* I noticed that the `with` keyword will probably almost always need capture blocks

```js
students: people.with(...)
	occupation = "student" // filter for people that have the occupation "student"
	type = "Student" // add the type tag "Student"

```

* because `with` is a function, so it's almost always called (not cloned)
* and the arguments are conditions, so they are probably long enough to warrant separate lines
* I mean, tbh, it doesn't look that bad

* however, I did also notice that "functions" are almost always called
* it's rare to clone or modify a function
* because usually, the name already indicates that it's a function, an action
* `sum`, `with`, `product` etc

* so it kinda goes back to the idea that, if there's outputs, it should be treated as a function

* however, the syntax still won't work well for inline declared functions
* eg `map(x => x*x)`
* this will get evaluated as a value, so it will pass the value of `x*x` into `map`
* what we really want is to pass the function `x => x*x` to map
* so we'd have to use braces, like `map({x => x*x})`
* this was actually discussed in the section "Different Syntax for Calling vs Cloning"

* another reason why dynamic might be better:
* it doesn't really make sense to call a module
* when calling a module:
	if it has values, and you want those values, you could have called it
	if it doesn't have values, and you want the new module, you can call it
	if it doesn't have values, and you want to call it, you know you'll just get empty

### Incomplete vs Complete

* after talking with veggero about incomplete vs complete functions, and thinking about it some more,
	it seems like the idea of incomplete functions has more merit than I originally thought
* I originally thought it would be almost impossible to tell if a function was incomplete
* because in a dataflow language, you don't know if an input is going to be undefined or not
	* talked about in the section "Currying and Returns"
* but I realize now that, undefined is different from unbound

* and it actually seems to work for 99% of cases
* because when would you want to get the output of an incomplete function?
* it's just going to be undefined
* and veggero brought up a good point:
	when would you want to clone a complete function?
* it's already complete

* functional has this concept already, with how it treats currying
* in functional, when you have multiple arguments:
	* you keep passing it arguments until all arguments are complete
	* and then it returns the value
* this is really just that same concept, but you don't have to pass arguments in the same order

* undefined feels the same as unbound, from the function's perspective
* so if the function doesn't know if it's complete or incomplete, why should you have to know?
	* at least in terms of which variables you want from the function
	* you might not know what values are in those variables
	* but you know which variables you want

* in my diagram syntax though, it's very clear whether or not you want an output, or the entire module
* it's always pretty clear what you're asking for
	* be it a property, an output, or the entire module
* whether or not a function is complete, seems like a runtime thing, so it feels weird to rely on it
	* though variables being bound, is more static than I originally thought

* there are also a few issues
* if you wanted to be able to extract the value of incomplete functions

```js
foo: cond, foo, bar =>
	if (cond):
		foo
	else:
		bar

foo(true) // technically incomplete, but still has a defined output
;
```

* though note that you could pull out the output using `foo[0]` or `...foo`

* also, lists are technically the same as "complete functions"
* they are just a set of output values
* so you might want to clone them
* though you could always use `{}` for that
* and it might be better to be more explicit, especially with singleton sets like `{3}`

* when calling a function
	* if its complete
		* you would want the output
	* if it's incomplete
		* the output is probably undefined, so you don't want it
		* you might still get a output, if the incomplete values don't matter for that output

### Incomplete vs Complete II

* in the previous section "Dynamic Class/Function Revisited", I mentioned that inline functions look kinda ugly
* in fact, way back in the section "Syntax and Mechanics Brainstorm III", I talked about using syntax like:

```js
list.map(a+1) // because a is unbound, it is implicitely the first argument
list.map(a -> a+1) // this works as well
;
```

* so way back then, it seems like I already had this idea of incomplete functions
	* if an expression has unbound variables, it's treated as a function
* though it probably wasn't formalized very well in my head
* but now the idea of incomplete functions makes much more sense

* if we use unbound variables
* that means that we probably want to bind them later
* eg, when we call it with arguments
* so if there's unbound variables in the expression, it should return the function
* note that unbound is different from undefined, as talked about in the section "Incomplete vs Complete"

* in fact, there's no point to declaring unbound variables if the entire expression is evaluated
* because those unbound variables would be evaluated as undefined anyways
* and we could have just substituted those unbound variables for `undefined` directly

* in addition, if we wanted to extract values of incomplete functions, like discussed earlier
* we could just give some inputs default values

```js
foo: cond =>
	foo: undefined // foo is now bound, but undefined
	bar: undefined // likewise
	if (cond):
		foo
	else:
		bar a. b. c. #what #1 #2 #3 #5 10.

foo(true) // technically incomplete, but still has a defined output
;
```

* dynamic bindings could still be a problem, similar to how they are a problem with dynamic scopes
	* as mentioned in section "Clone Scopes and Dynamic Inputs"

```js
randomStrings: "cds" "ei" "2idkz" "a" "38sk10" "cat"

foo:
	for x in randomStrings
		(x): 10 // this would ruin the unbound input a
	map(a+1) // the value 11 is passed in, instead of the function a+1
	square: // square seems like a function, but it's actually a value now
		a*a
;
```

* though we could just explicitely declare inputs, eg `map(a => a+1)` and `square: a => a*a`

### Dynamic Calling based on Completeness

* so it seems like the new model for calling is:
	1. if it has no outputs, return as object
	2. if it hsa unbound inputs, return as object (aka function)
	3. otherwise, evaluate
* `{}` is still used for explicit cloning and creating objects

* also, note that the implicit brackets are `()` again
* coming full circle lol

### State Variables and Set Items

* I mentioned in the section "State Variables and Actions" about declaring state variables like `myVar.`
* now that function calling is based on which variables are bound/unbound, it's important to "bind" state variables
	in some way, so they don't get counted as unbound variables

* `myVar.` stands for `myVar: {}`, creating an empty object
* this automatically gives it a memory address, so we could also use this for defining symbols
* it also ensures that it is bound

* now that `{1 2 3}` now makes an ordered list, and we have to use object keys for sets,
	this also gives us a shorthand for defining sets

```js
foo:
	a. b. c. // can be used as symbols, state variables, and set values
;
```

* the `a.` syntax starts looking ugly with inline objects though
	* eg `foo: a. b., x: 10` (we need the comma to separate it from the property `x: 10`)
* maybe we can use `#` instead, like `foo: #a #b, x: 10`
* but it doesn't look as good for sets

```js
foo:
	#a #b #c // can be used as symbols, state variables, and set values
;
```

### Closures and Dynamic Functions II

* anonymous functions allows for closures

```js
foo:
	bar: (x := 0, inc: (x++, x), inc)
	bar() = 1
	bar() = 2
	bar() = 3 // I think this should work...

```

* `x` and `inc` can never be accessed or referenced
* but their affects are visible

### Overriding Outputs

* if you override the outputs/values of an existing object, it replaces the existing values
* `foo: {1 2 3}`, `bar: foo{10}`, `bar = {10}`
* if you want to keep existing values, you have to do so explicitely
* `bar = foo{...foo.values 10}`
* in this case we could have just done `bar = {...foo.values 10}`, no cloning necessary
* but cloning can be useful if we want to override or reference properties as well

### Escaped Symbols

* in state variables and reductions, we used the variable `prev` to reference previous states/values
	* see section "`For` Keyword"

* there are also times when you want to reference variables from outer scopes with the same name
* eg, `x: x+1` where it isn't feedback, but instead is "redefined" `x` in the current scope
* or `fn: (x y => x+y), gn: fn(...values x+y+z)`, where `values` should refer to `fn.values` not `gn.values` (or else feedback)

* perhaps we can use `prev` for that as well?
* the problem with the word `prev` is it's a shortened word, usually keywords are full words, like `previous`
* also, reserves a variable name that could be useful elsewhere

* maybe we can use a symbol, like `^`, eg `x: ^x+1`
* looks kinda ugly though
* maybe the `..` operator like used to go up a folder, `x: ..x+1`

### Why Undefined?

* this is a continuation of the section "Null is Evil?"

* me and veggero were debating a bunch about whether or not to have the `undefined` value
* one of the biggest criticisms of stuff like `null` and `undefined` is that they are lazy
* they subvert the type system. Any type can be "undefined", so programmers default to it instead of actually defining every case

* in the section "Null is Evil?" I talk about how functional languages don't need `null` or `undefined`
* and compiled typed languages can guarantee zero runtime errors if the compiler succeeds, without using `null` or exception catching
	* see "PonyLang" for an example
* they achieve this by accounting for every case, maintaining type safety even when doing things like dividing by zero, or out of bounds array access

* in the section "Null is Evil?" I also talk about how compiler errors are the same as `undefined`
* that isn't necessarily the case
* first off, Arcana can throw parse errors too (though modules that don't parse or have syntax errors simply evaluate to undefined, when running in a network of programs)
* but also, compiler errors can also be represented using a defined type
* like a `Compiler` class, that takes in a `Program` class, and spits out a `CompilerResult` class, which can be an error or the compiled program

* so yes, it's possible to do without `null` or `undefined`
* however, it forces you to account for every case
* and dynamic languages are supposed to be fast

* using `undefined` as a default, and building from there
* it allows you to create "incomplete" programs
* which is fast
* often, accounting for every case is unrealistic
	* especially in an un-typed system, where other programs can give you whatever data they want, corrupt data or invalid types or wrong number of inputs, etc
* it's much more practical to have cases where you just throw `undefined` to indicate that those cases aren't accounted for
* declaring the program behavior is literally `undefined`
* instead of trying to define everything

### Dynamic Keys and `is` keyword

for `:`
if you pass a object/value, it checks for equality
if you pass a function, it calls the function with the key


* `object.is(...)` function takes a single argument and if it is:
	* a value or module, checks for equaliy
	* otherwise, it's a function, call it with the source object as argument, and see if it returns true
* examples

```js
x: 1
even: n => n%2 = 0

x.is(1) // true
x.is(2) // false
x.is(<10) // true
x.is(even) // false
;
```

so dynamic keys use `is`?

### Conditionals

* you can use `?` in place of `if`
* if the condition is a value, check if truthy
	* otherwise, if it's a function, call it with declared inputs?

### Matchers II

```js
coffee.capacity:
	equal(coffee.size,...)
		"small": 
		"medium":
		"large":

```

### Metaprogramming Systems and Type System Example

* recall the idea of systems
* that using metaprogramming and local variables, we can define hidden properties and rules for programs
* any program defined with the "system" inherits those hidden properties and rules
* these systems often act like contracts, where every program that joins the system agrees to the contract, and must abide by the rules

* for example, one thing a type system enforces is that functions must pass the right datatypes to other functions
* normally, in an un-typed dynamic system, it's free for all, and if a function wants to pass in invalid data or wrong types, that's just something the programmer has to account for
* however, with a type system, a compiler can go through all the types and make sure there are no conflicts
* this compiler is part of the "type system", and is just a metaprogram
* in addition, any variables in this type system have the hidden "type" property that statically binds them to their types, making property access faster
* alos ensures that, any program that passes the compiler, is guaranteed to run without errors or `undefined` values

### State Variables as a System

* state variables is actually an example of a system as well
* state variables are a datatype with special rules in the background
* any function called by an event or reduction has an associated `index` property
	* for reductions, this is the index of the items
	* for events, this is the event time
* in addition, the system searches these functions for modifications to declared state variables
* the system appends the modifications to the state variables with the associated index
* and the index is used to order these modifications

* in addition, these indices have an associated `index_type`
* for events, the index type is just `time`
* for reductions, the index type points to the source list
* the system checks to make sure all modifications have the same `index_type`
* so you can't just mix reductions and event listeners together, doesn't make sense
* these checks can be performed statically, before the program is even run!

* `index` and `index_type` are hidden variables
* so you can't mess the system up

### Functions As a System

* functions can be viewed as a system too!
* recall that function calls is just accessor pattern
* we can replicate functions with an `fn_result` property
* this is basically like Nylos `->` property
* any object with this property is considered a "function"
* the system overrides the cloning operator to add this behavior:
	* if the object has the `fn_result` property,
	* and the object has no unbound symbols
	* extract the values after the cloning operation
* now instead of using `fn_result`, just use list values instead
* and that's basically the function calling system we have right now

### Making a Type System

* our cloning system already has the markings of a prototypal type system
* in fact, if we wanted a type checker, we can simply use type inference to check for conflicts
* some discussion on type inference systems [here](https://en.wikipedia.org/wiki/Type_inference)
* but a super simple version would be to just
	1. start at created objects and input nodes (eg `stdin`), all of which have predetermined types
	2. traverse forward, looking at all places these objects are used
	3. statically bind types as they are being inferred
	4. make sure there are no conflicting property accesses or types
	5. make sure `undefined` is never explicitly used in the program
* if the type inference passes without issue, then we are guaranteed that the program will run without errors
	* no `undefined` either
* the static type binding allows for faster property access as well

* for example

```js
Vector:
	x, y // note: unbound, so treated as symbols

input: stdin() // a string
inputNum: intFromString(x) // so y must be a Number
p: Vector(x*x, 5) // so Vector.x and Vector.y must be Numbers
mag: magnitude(z) // magnitude.v must be a Vector, so bind v.x and v.y inside magnitude to Vector.x and Vector.y
mag2: magnitude("hi") // ERROR. first problem is, magnitude.v was inferred to be a Vector but a String was given.
                      //        second problem is, String.x and String.y don't exist, so property access error as well.

magnitude: v => Math.sqrt(v.x*v.x + v.y*v.y) 
;
```

* lets say you wanted to go a step further, and add explicit type declarations
	* so the IDE can provide suggestions and autocompletions and such, before types can be inferred
* then you can add a rule to ensure that all unbound symbols are:
	1. declared at the top of the function
	2. accompanied with a type
* eg `sum: Int a, Int b => a+b`

### Privacy-First System

* for programs deployed to the internet, you probably don't want to expose all your variables
* so instead of keys defaulting to public string values, they stay as private values
* `mykey: myvalue` is now equivalent to `(mykey): myvalue`, instead of `"mykey": myvalue`
* you have to explicitly say `"mykey": myvalue` to declare public properties

### Immediately Invoked Function Expressions

* we kinda talked about someting similar to this idea in the earlier section "Indented Expression"
* remember that, expressions with all bound variables and at least one output, will automatically be evaluated
* this allows us to quickly define a throwaway block with some local variables for long calculations

```js
x: 10, y: 20
myMagnitude:
	x2: x*x
	y2: y*y
	Math.sqrt(x2+y2) // automatically evaluated
;
```

* note that in the later section "`()` to Rule them All", the syntax for this slightly changes

### Lists and Cloning

* while I was writing my readme, I was talking about how lists have to be cloned, otherwise they would get evaluated as functions

```js
mylist: {1 2 3} // note that using () braces here would have extracted the values 1 2 3, so use {} to force it as an object

mylist{tag: "list"} // using () here would have extracted the values again, so use {} to force as cloning
;
```

* didn't really feel right
* doesn't feel clear or intuitive when to call, and when to clone
* I know it's a list, so shouldn't the language already know to clone it, instead of calling it?

* it also feels like we are changing behavior based on the data
* eg, how many values are in the object (if values exist, treat as function, otherwise treat as object)
* this is different from checking for unbound variables, because unbound/bound is a static concept
* data is dynamic
* behavior based on data seems bad
* we don't always know how many values there are in an object
* so it will always be dangerous to use `()` on an object

* or maybe every time we call, we only extract values
	1. started as incomplete (<-- this is new)
	2. became complete
	3. has static outputs

* or perhaps calling vs declaring expressions is different

* it matters what it was declared as
* if it has static outputs and unbound inputs, it was declared as a function
* otherwise, not
* so I guess function is a type after all...

* right now when we want to extend/clone a list, we have to be careful to use `{}`
* for regular object we can clone using `()`
* but aren't lists basically objects? why the special treatment?

### Unbound Lists

* So it seems like the difference between functions/objects probably has to be static
* we know what we want it to be treated as from the beginning
* for functions, we know we eventually want the values, whereas for objects we know we always want the object

* in addition, from the section "Functions as a System"
* if functions are a system, then it makes sense that functions are like a data type
* and data types are (usually?) statically declared

* another problem with dynamic:
* what if we wanted a list with unbound properties?
* "completing" those properties shouldn't extract the list values, like how a function works
* it should just clone the list, like any other object
* problem is, lists with unbound properties look identical to functions

* example of a list with unbound properties

```js
rightTriangle: { x y Math.sqrt(x*x+y*y) } // not properties, unbound values
p1: rightTriangle(10,20,30) // what I expect: { 10 20 30 }, what I got: 10
p2: rightTriangle{10,20,30} // you'd have to clone it like this
;
```

* actually, it's even weirder
* due to unbound symbols, `{ x y Math.sqrt(x*x+y*y) }` evaluates to a function `x y => { x y Math.sqrt(x*x+y*y) }`
* so:

```js
p1: rightTriangle(10,20,30) // what I get: { 10 20 30 }

// but when you try to access list values, it's weird because its a function with one output
rightTriangle[0] // what I expect: x, what I get: { x y Math.sqrt(x*x+y*y) }
rightTriangle[1] // what I expect: y, what I get: undefined

```

* a different way to create these unbound lists is to make `rightTriangle` a value with three outputs, and use cloning instead of calling

```js
rightTriangle: x y Math.sqrt(x*x+y*y)
p1: {rightTriangle(10,20,30)} // or you could do rightTriangle{10,20,30}
;
```

* all of this is rather unintuitive

### Static Declaration of Objects

* if you want a list, it should be treated as a list
* the properties should be treated as `0: a, 1: b`, not `a, b`

* maybe just use `[]` to statically bind it as a list during declaration

* actually, I can just use `{}`!
* `{}` should basically force things to be evaluated as objects

* so instead of evaluating objects as "function-like", we force objects as object-like
* then special cases (unbound + has outputs) are statically bound as functions

* so a list is declared with braces, `{ x+y }`, and a function is declared without, `x y => x+y`
* the resulting objects are internally identical
* so it can't be dynamic
* so it seems like functions/objects have to be statically declared at the beginning after all

### `()` to Rule them All

* note that veggero uses one bracket, `()`, to create objects
* I had this before as well, but I turned `()` into a more dynamic operator, and reserved `{}` for only cloning and object creation
	* I also noted that `{}` was necessary for singleton sets, like `{1+2}`, as explained in the section "Singleton Sets"

* however, since we are using `{}` to force objects now, maybe we can just go back to using `()`

* it sorta makes sense, because there's no reason to use it if you don't want an object
* cuz you can just declare lists like `foo: 1 2 3` instead of `foo: (1 2 3)`

* the only issue comes back to singleton sets

* is `(8)` a set of 8, or the value 8?

* actually, singleton sets is only an issue because of operators
* `(8)` should be a set, because if you wanted the value you could just use `8`
* but expressions like `(3 + 5)`, can be interpreted as `{8}` or just `8`
* without operators, if we used functions, the distinction is clear:
	* just 8: `sum(3 5)`
	* set of 8: `(sum(3 5))`

* so we just need to solve the case for operators
* before, I considered the case that operators "consume" parenthesis
* so you need double parenthesis for singleton sets with operators inside: `((3 + 5)) = {8}`

* however, parenthesis aren't needed if there's only one operator
* if we wanted `8`, we could just do `3+5` instead of `(3+5)`

* you use parenthesis with operators if you want to define precedence
* like `(3+5)-10`
* thus, the `-` operator is actually the reason for the parenthesis
* so the `-` operator is the one that should be "consuming" the parenthesis
* `{8}-10` doesn't make sense anyways

* in other words, operators extract values out of singleton sets
* `(3+5)` evaluates to a set, but then the `- 10` extracts that value
* this can probably be extended to all operators

* though, parenthesis in large expressions is also commonly used as a delimiting tool
* note that this is actually two values, even though it's hard to tell: `( 3 + (5/foo) ) * 4 10`
* would be easier if you did `(( 3 + (5/foo) ) * 4)  (10)`

* though you could just increase whitespace: `( 3 + (5/foo) ) * 4	10`
* or use commas: `( 3 + (5/foo) ) * 4, 10`

### Summary of Objects/Functions

* `()` is used to declare objects
* if `()` is not present, it is evaluated as an expression, unless:
	* there are unbound inputs and at least one output, which makes it a function
	* there are no outputs, which makes it an object

* actually, to simplify the rules further:

* `()` is used to declare objects
* otherwise its a function
* functions are evaluated once they have no more unbound variables

examples:

```js
nums: (1 2 3) // a list
rightTriangle:
	x, y, Math.sqrt(x*x+y*y) // implied parenthesis makes this a list
distance: x, y, Math.sqrt(x*x+y*y) // no parenthesis, so a function
a, b: 1, 2 // no parenthesis, so a function. However, since no unbound values, it is immediately evaluated
foo: a: 10, b: 20 // we technically could immediately evaluate this (which results in no values), but I think this should be a syntax error
foo: => a: 10, b: 20 // if we really wanted to do that, we could use this instead
foo: ...(a: 10, b: 20) // or this

bar: ... // ... + implied parenthesis = expression
	x: 10
	y: 20
	x+y // because all values are bound, it is an "immediately invoked function expression"

zed: ... // ... + implied parenthesis = expression
	x+y // unbound values, so stored as function

Person:
	name age occupation // implied parenthesis, so an object
Bob: Person
	name: 20

divide: Math.floor(nom/denom), nom % denom // a function that returns quotient and remainder
divideObj: (divide) // turn function into an object
quotient, remainder: divide(100, 7) // binding
(quotient, remainder): divideObj(100, 7) // object deconstruction

divide2: ...divideObj // turns the object back into a function/expression

```

### retrospect - FINISH THIS

-------------------- FINISH THIS --------------------

-------------------- FINISH THIS --------------------

-------------------- FINISH THIS --------------------

* thinking back to what I got wrong

* incomplete vs complete

* static vs dynamic typed
	* key example: lists and unbound lists
	

its not about using the same data
its about how functions are thought about
as temporary objects, that spit out a value when given all inputs


it is possible to want to clone a function


diagram dataflow doens't have the concept of calling vs cloning
doesn't have the concept of incomplete vs complete

at every step, you know whether or not you want to pull a value/object

functions are a tool for defining expressions that, you know you want the value of, but only after all arguments are complete
so you have to keep track of what arguments are needed, are unbound
which isn't too hard I guess

but it can be tricky if you had something like `x: foo(...args)`
where `args` is a provided list
you know you want the value from foo
but how do you ensure that `args` has enough to complete `foo`?

in the diagram language, you can just pull out the result
and if `args` doesn't complete `foo`, the result will be undefined

but with functions, depending on `args`, the result can be the result of `foo` or a temporary `foo`

### Syntax Exploration

```js
fibonacci: n =>
	if (n > 0) fibonacci(n-1) + fibonacci(n-2)
	else n

fibonacci_memoized: n =>
	a, b: 1, 0
	result: for (1 to n)
		a: ^a + ^b
		b: ^a
	result.a

fibonacci(6) = fibonacci_memoized(6) = 8

Person: (age: 0, name: "")

Bob: Person
	name: "Bob"
	age: 20

(1 2 3).map(x*x) = (1 4 9)

(x)? 20 // conditionals
else (x+y)? 30

even: x => x % 2 = 0
mylist: ( 1 2 3 4 5 )
even_items:
	for x in mylist:
		even? x*x

odds: (...).keys // capture block
	even(key+1): true

sum2: sum(_ 10) // keeps first argument unbound

_ x _ y: bla()

foo: x,y  =>
	sum: x+y

foo(10,20).sum = 30
foo.sum(10,20) = 30
// foo.sum returns a function (x, y => x+y)
// some might say foo.sum should be undefined, because it represents the value if x and y were to exist
// but actually, this allows me to do `foo.sum(10,20)` without calling foo
// allows for libraries and stuff

divide: Math.floor(nom/denom), nom % denom // a function that returns quotient and remainder
...divide // forces value extraction

```

### Dynamic Keys Syntax

* because `()` is being used for object deconstruction now
* dynamic keys now use `[]`

```js
foo:
	localkey.
	[localkey]: 10
```

* in fact, this makes sense because to access it, you would use `[localkey]` as well
	* see section "Square Brackets without Target"

* you can also use functions/matchers within this as well, like `[>10]: "hello"`
	* this will return "hello" when accessing any key >10

### Capture Blocks vs Immediately Invoked Function Expressions

* so instead of capture blocks, we can actually do something like
* 

```js
foo: fn1(a).fn2(b).fn3(c, d)
	a: 10
	b: 20
	c: 30
	d: 40
```

* because this actually treats the first line as an expression, a function `a b c d => fn1(a).fn2(b).fn3(c, d)`
* and then the indented block is treated as arguments to that function!!

* another example:

```js
foo: website.getPage(url).getElementsWithClass(class).addProperties(obj)
	url: 'https://github.com/woojoo666/arcana-notes#untitled-language'
	class: 'class'
	obj:
		a: 10
		b: 20
		c: 30
```

* makes it easy to see the "chain" of events, with long arguments moved into the inner block

### Functions Syntax

* so we have to use this syntax for functions now

```js
sum: ...
	a, b =>
	a+b // implied parenthesis + unbound variables makes this a function
;
```

* however, maybe we can allow the declarations to be moved to the first line

```js
sum: a, b =>
	a+b
;
```

* technically this implies `sum: a,b => (a+b)`, which returns an object not a value
* but maybe we can treat this as a special case
* we could alos just use object deconstruction when calling the function, `(x): sum(10, 20)`

* another problem is with inline functions
* `map(x => x, 10)`, is this
	* two arguments, like `map((x => x), 10)`
	* a single argument, but a function that takes two objects `map(x => (x, 10))`

* same problem with indented blocks

```js
sum: ... // how many of these are function returns? how many are just values?
	a+b
	10
	b+20
;
```

* actually, this works!!

```js
sum: a, b => // declares a function with no output
	a+b // gives the function an output, without binding any variables, so function is still incomplete
;
```

* we can carry over the idea from "Capture Blocks vs Immediately Invoked Function Expressions"
* basically, the first line, `a, b =>` defines a function with no output
* the indented block gives the function properties and outputs, and as long as it doesn't complete the function, we're good

* we can also do

```js
sum: a, b => a+b
	a: 10
;
```

* which basically does the same thing, except the output is declared on the first line
* and properties are declares in the indented block

* these examples work on the assumption that the first line is evaluated by itself, before evaluating the indented block
* if we instead took "implied parenthesis" literally, and converted the above into `sum: a, b => a+b(a: 10)`
	then it doesn't really work
* so there has to be this concept of treating the first line as a single entity
* and perhaps each line should be treated as a separate entity

### Multiple Output Functions vs List Values

what if I had something like

	fn(x+y, 10, x-y, 20) // x and y are unbound

multiple ways to interpret this
	four separate arguments
	first argument is a function x y => x+y, 10, x-y, second argument is 20
	first argument is a function x y => x+y, second argument is x y => 10, x-y, 20
	etc...

maybe we can explicitely delimit it like so

	fn(x+y, 10, x-y)(20) // first call has one argument: a function with three outputs

or maybe a special operator, `fn(x+y, 10, x-y | 20)`

but function arguments are an object, just like regular objects
so if we're having problems with this, then regular objects probably have the same problem

	args:
		x+y, 10, x-y, 20

this can be interpreted as this

	args:
		0: x+y, 10, x-y // a function with three outputs, the first of which will be bound to "0"
		1: 20

so ambiguity here as well

### Functions Have a Single Output

so it seems like a function's multiple outputs can be mistaken for list values, and vice versa
perhaps we should force multiple function outputs to be wrapped in a list
aka functions can only have one output

then what happens if you try to define multiple?
(x y => x+y x-y)
this actually defines an incomplete list
which is basically the same as a function that returns a list!

what happens if we try to "spread" an unbound list?

foo: ...
	x+y
	x-y

this actually results in two functions!

functions are just incomplete expressions, like sum(divide(x,y),multiple(c,d))

in fact, if we spread out something like

	foo: x, y, z =>
		x+y
		z
		y+10
		3

we get

	x y => x+y, z => z, y => y+10, 3

a function that returns a set is the same as a set of functions!

we can think of expressions as complete functions
when you use a function, its like a dormant value, so you can't really do anything with it
other than clone it, and set some values, and see what the result is then
imagine lazy evaluation. when you ask for the value of a complete expression,
	it backtracks until it evaluates the entire thing into a single value
whereas, if the evaluation fails, it just returns the expression

### Functions are Values

* functions and expressions are just "values" with the entire evaluation structure behind it
* it is dynamic, pulls the entire evaluation structure with it
* no such thing as incomplete, and complete
* parameter declarations are useless
* inputs are implied

* the "boundaries" of a function don't actually exist
* this is why in the earlier section "Syntax Exploration", we could do

```js
foo: x,y  =>
	sum: x+y

foo(10,20).sum = 30
foo.sum(10,20) = 30
```

* so what is being cloned?
* where are these "inputs" exactly? how do you override them?
* when you clone an incomplete expression, you can fill in values in the scope of the function
* but what if you have something like this

```js
foo: x, y =>
	a: x+10
	b: a*y
	bar: z =>
		c: a/(b+z)
		c*c // result

```

* foo.bar is a function
* are you allowed to do
* foo.bar(x: 10, y: 20, z: 3)?
* imagine if all variable names were unique, then this would have no problems, right?

* but if there's repeat function names, then maybe it should propagate "backwards", looking for unbound symbols to override?

* functions represent the "tip" of this evaluation tree
* they don't represent a "scope" with an output, they represent the output itself

* go to diagram syntax
* show how objects can be thought of as a bunch of references to dependencies
* I used to think functions were like special modules, that clone until they are complete, and then they return a value
* now I see that, a function is simply a variable bound to the output of a module, instead of the module itself

* when you clone an object, it can only clone and override the direct references
* so when you clone a function, it does the same

* the key difference is **a function is where the object being cloned is not the same as the object being returned**
* you can think of a regular object as one where the object being cloned is the same as the object being returned

### Functions and Objects - A Unified Theory

no such thing as incomplete and complete
	* revisit: actually there is, see next section "Incomplete vs Complete Revisited"
	* revisit: actually there isn't, see next next section "Partial Completion"
objects are a subclass of functions (but they are ultimately the same thing)
static, not dynamic
	* objects are where scope and output are the same, functions are where they are different
	* actually, they can be viewed as the same, discussed in the section "Propagating Incompleteness"
	* if you consider the object wrapper `(  )` as part of the expression as well, then they do end up being the same

looks like the diagram syntax ended up coming in handy after all!
(helped me think about the problem better)

so what happens if we spread out

	foo: x, y, z =>
		c: x*x
		c+y
		c-z

do we get

	(x y => c: x*x, c+y) (x z => c: x*x, c-z)

or is the `c` property outside of the functions?

	c: x*x, x y => c+y, x z => c-z

probably the latter


### Incomplete vs Complete Revisited

you can kinda think of functions like trial-and-error
you keep cloning the function source, changing variable here and there
and then inspecting the output each time to see what happened
in this sense, it does make sense to clone the output, even if it is complete
though, the complete output might not be the same as the function
the evaluated function output is not the same, they are just "equal"
just like `1+3 = 4`, but `1+3` has a difference structure behind it than `4`
so if functions work the same way, then calling it will keep overriding, until its complete and the output can be evaluated
	at which point the evaluated result takes the place of the original clone source evaluation

* so how do evaluation models fit into this whole graph model of objects?
* maybe each node has both an evaluated "value" and all the properties and operations that went into it?
* this sounds like mixed nodes

* say there was a function getRGB that returns a color in rgb format, with properties `r` `g` `b`
* when you call the function getRGB, it should first return the color, and then when you call the result of that, it clones the color
* so clearly they are pointing to different nodes
* there is a concept of incomplete and complete

* declaration matters
* `foo: getRGB('green')`
	* `getRGB` is incomplete, but `getRGB('green')` is complete, so that's the difference between `foo` and `getRGB`

### Functions and Expressions

* if we had `Math: (sum: x+y)`, and we did `Math.sum`, it returns a function
* because `Math` and `sum` are both bound variables
* the scope of each function is just the expression 

* functions and objects are the same thing, functions aren't a separate system
* lists are the only "added" system, just a shorthand for numeric indices, and an extra spread operator that works with binding

* what is the function scope? what is cloned during the function call?
* does function scope change when you extract functions?

* originally I thought that, if you extract a function, it should still use the original function scope (the scope you extract it from)
* the diagram syntax made it look that way
* but for a bunch of nested scopes, being able to choose which scope is cloned is convenient
* if you only want to use a deeply nested function, you shouldn't have to clone the entire thing

* it's based on the expression the symbol was declared with
* the expression associated with `Math` is `(sum: x+y)`
* the expression associated with `sum` is `x+y`
* these determine what scope is cloned

### Function Extraction

* note that accessor pattern works, even though I thought it didn't for a while
* I was just putting the operator in the wrong place tbh
* `map(x => (result: x*x).result)` doesn't extract `result` until after the function is complete
* the entire expression is `(result: x*x).result`, not just `(result: x*x)`

* the spread operator is really just accessor pattern
* the spread operator is part of the function!
* so ...(expression1, expression2, expression3) doesn't actually create 3 functions
* it's still a function that returns three objects
* so if you did `foo: ...(expression1, expression2, expression3)`, you can clone `foo` to complete all expressions, and get all three values back
* though does it make sense to get multiple values, not wrapped in a list? `foo` and `foo(...)` should represent one value, not multiple
* so perhaps the `...` operator should extract the expressions beforehand

* but then are we allowed to extract `Math.sum`?

* so which operators are evaluated, which aren't?
* maybe it tries to evaluate everything it can?

### Propagating Incompleteness

* what happens if we have multiple expressions referencing/sharing the same unbound symbol?
	* eg `foo: (sum: a+b, product: a*b)`, where `a` and `b` are shared across `sum` and `product`
* technically, that symbol is declared in each expression
* but because it's shared, maybe it should be part of the outer scope
* but you can always add it to the outer scope if you clone the outer scope, so perhaps the behavior is the same either way

```js
MathXY:
	x: a, y: b
	sum: a+b
	product: x*y
```

* in `sum`, `a` and `b` are unbound, but in `product`, `x` and `y` are bound
* or is it supposed to detect that `x` and `y` are unbound as well? does it propagate?

* what if I do `foo: x => a: x*x, b: 10` so foo is a function, but then I do `foo.a`? what about `foo.b`?

* I don't think "incompleteness" should propagate
* so in the above `MathXY` function, `product` returns a value, `undefined`
* completely based on what variables are undeclared in the expression
* incomplete expressions have a temporary scope
* that's where all the overrides go, and extra variables

* incomplete objects are incomplete expressions, because the object wrapper `(  )` is an expression as well
* only difference is that the temporary scope is the object itself? so not actually temporary?

* but what about `MathXY.sum`? it's variables can be thought of as bound to the unbound variables `a` `b` used in the `MathXY` scope
* technically they are the same variable
* but perhaps in the `Math` scope, it's considered unbound, but in the `sum` scope, it's considered bound?
* or maybe, if bindings are inherited through scopes (as in, if an outer scope declares a variable, inner scopes will inherit the variable and auto bind to it),
	then "unbound" should be inherited as well?
* propagation of "unbound" to variables that use that an unbound variable, and so on
* propagation of incompleteness

* another example:

```js
fn: // a, b are unbound
	x: 10/a
	y: 20+b
	result: x*y
```

* if "incompleteness" propagated, then `fn.result` would be a function with `x` and `y` as inputs
* but that doesn't really make intuitive sense

```js
fn: // a, b are unbound
	x: 10/a
	y: 20+b
	result: x*y+c
```

* but then it doesn't really make sense fo `fn.result` to have input `c` either, right?
* but maybe, if you call `temp: fn(a: 3, b: 5)`, then you can do `temp.result(c: 7)`
* it's like initializing the global variables of a library, and then pulling individual functions out
* a function's unbound variables are based solely on it's own expression, and which of those variables are unbound
* doesn't care about what happens in outer scopes, even if one of it's "bound" variables turns out to be unbound, like the case of `fn.result.x`

* this also indicates to us that, even though `x` and `y` are functions, `result` sees them as values
* so functions should evaluate to the value `undefined` when viewed? and only when you call them, can you access the function scope?
* does this mean that all nodes have values and properties? perhaps values are associated with their evaluation system? so Numbers have a `numeric_value` property, strings have a `string_value` property, etc
	* and type coercion converts between them
* this is actually how mixed nodes can work. "viewing" and "printing" an object is something that can be overridden. If it's a number, the `numeric_value` is printed out. If its a string, the `string_value`. If it's a color, it prints out the `r g b` properties. I think by default it should just print out the properties

### Implicit Declarations

* going back to the `MathXY` example:

```js
MathXY:
	x: a, y: b
	sum: a+b
	product: x*y
```

* it actually makes sense that `sum.a` and `sum.b` are considered bound
* because they are first used in the outer scope, and because scope binding is basically just outer scopes passing variables into inner scopes
	* talked about in the (much earlier) section "Scope Passing and Nested Modules"
* the first usage of an unbound variable is like an implicit "declaration"

* this also means that, shared variables are not considered bound, because they aren't implicitly declared in the outer scope
	* eg `foo: (sum: a+b, product: a*b)`, the symbols `a` and `b` are considered unbound in both `sum` and `product`

* the IDE highlights the first usage of unbound symbols, so these implicit declarations are obvious

### Function Scopes

```js
fn1 fn2: ...
	x: 10/a
	y: 20+b
	x+y
	x*y
```

* so this creates a temporary scope, that looks like `(...(x: 10/a, y: 20+b, x+y, x*y))`
* but shouldn't you be able to access `fn1.x` and `fn2.y`? you wouldn't be able to if the entire thing is wrapped

* note that, in the above function, even though `fn1` is bound to `x+y` and `fn2` is bound to `x*y`, the function scope is the entire indented block plus the `...`,
	and both `fn1` and `fn2` inherit that functions scope
* this is because function scope is based on the entire expression, not just the function output value

* perhaps `...(   )` and `(   )` are special cases for function scope
* makes sense for `...(   )` because it should be equal to the behavior of
	1. object deconstruction: `(fn): (a: 10, a+b)`
	2. inline functions: `fn: => a: 10, a+b`
* what about `fn: someParentFn(  argscope  )`
* in this case, the function scope should not be the same as `argscope`
* so it does seem like `...(  argscope  )` is a special case

* what about accessor pattern?

commutivity/associativity:

	foo(a b c)[x y z] = foo(a)[x](b c)[y][z] = foo[x y z](a b c) = foo[x y](a)[z](b c)

* though this doesn't always work because extracted functions have their own function scope, and don't use the parent function scope
* eg for something like `foo: (a b c => x: (y: (z: 10)))`, then `foo[x y z]` would just be 10, and the arguments `(a b c)` would be discarded

* however, this commutivity holds true if `foo` was something like `foo: (a b c => x: (y: (z: a+b+c)))`

### Evaluation Systems, Mixed Modules, Incomplete vs Complete

* towards the end of section "Propagating Incompleteness", we talked about evaluation systems
* how functions could store both their expression and their evaluation result
* the expression would be the structure used to calculate the result
* the evaluation result would be stored in `numeric_value` or `string_value` or some other property, depending on the evaluation system used

* this makes sense because, the expression would never contain a `numeric_value` or `string_value` on it's own, so no possibility of conflicts
* even if the expression was an object, because `numeric_value` and `string_value` are hidden
* maybe mixed modules work after all?

* what about getRGB example?
* what does this mean for Incomplete vs Complete?

* no, as I already said, there is a difference between the evaluation structure, and the value we are pulling out
* the output of the function is not the entire expression used to create it

### Dynamic Functions and Inputs

(in this section I completely rethink incompleteness propagation)

* `a b c: ...(x y z)` binding is actually deferred until function is complete
* because if you had a function `fn()` that returns a list, and you did `a b c: ...fn(x y z)`, it can't extract the functions yet
* or can it? should it?
* I guess it is just shorthand for `temp: (x y z)`, `a: temp[0], b: temp[1], c: temp[2]`
* but in this case, `temp[0]` is bound, so `a` will just be undefined

* also ,consider this function

```js
VectorMath: vec =>
	dot: other_vec => vec.x*other_vec.x + vec.y*other_vec.y 
	magnitude: dot(vec)
;
```

```js
negMath:
	negativeY: -y
	difference: x+negativeY
	// I couldn't think of any other function where you might want to use negativeY, but I can see it being a possiblity
```

* in this case, incompleteness does propagate
* but that isn't how we should think about it
* don't think of functions as incomplete expressions
* we think of our program as a graph, and functions are just output nodes of that graph
* when we "pull out" an output, it will pull out any inputs related to it

* how does it work with shadowing?

```js
foo:
	y: x*x
	bar:
		x: 10
		fn: y+1
```

* we might think that `fn(x: 5)` should override `bar.x`
* however, the input related to `fn` is actually `foo.x`
* this seems pretty weird
* however, note that any "variable shadowing" won't affect the inputs to nested functions, because only bound variables can do variable shadowing
	* (eg, in this case `bar.x` is bound)
* and when pulling out functions, it only searches for unbound variables, conveniently ignoring any of these shadow variables
* `bar.x` would only come into play if we did `fn: y()+1` and we had dynamic scope inheritance

* this whole output extraction is super dynamic
* however, this also means that inputs can become unclear
* Math(2,3,4).sum is the same as Math(2,3).sum and Math(2).sum(3) and Math.sum(2,3)
* but notice how the arguments for `sum` change
* the first argument for `Math(2).sum` is `y`, but first argument for `Math.sum` is `x`
* argument order gets really weird

```js
foo:
	x y
	bar:
		a x b
```

* `foo(1).bar`binds `x`, which takes out the _middle_ argument of `bar`
* what would help alot is for the IDE to automatically show what inputs are unbound when calling a function

* how does feedback play into all of this?

### Partial Completion

* before I thought of objects and functions as the same thing
* but objects are structural, they have properties
* an output doesn't have properties
* so it doesn't make sense to make outputs objects
* properties point to the output scope

* properties are to facilitate binding?

* actually, if we look at the diagram syntax (see notes on Dynamic Functions in "Objects vs Functions.one")
* we can see that "outputs" are the same thing as objects
* objects are just the output when we use the `(   )` object-creation operator

* we should be able to access completed properties, even if some other properties are incomplete
* imagine the `getRGB` function, and imagine that the `r` `g` and `b` properties are computed separately
* perhaps we pass in enough arguments to compute `r` and `g`
* we should be able to access those properties
* but we should _also_ be able to add more arguments to complete the `b` property

* what about something like `x: (a+b)/(c+d)`
* `x` is the result of the `divide()` function
* the `divide` function sets the `numeric_value` property
* you can call `x` to complete the arguments, and when all the arguments are given, then the `numeric_value` property is defined
* but you can still use `x` when it's incomplete, it will just pass `numeric_value: undefined` to other math operations

* but then what about properties? if overriding arguments propagates backwards, then doesn't this get really messy for overriding properties?

* this comes back to partial completion
* every output/object is a node, with properties
* each of these properties can be complete
* accessing/overriding properties only takes the properties that belong to the node
* giving inputs traverses backwards to any inputs that lead to the output

* what happens when an input has the same name as a property?

```js
foo: x =>
	a: x+1
	bar:
		x: a*a // shadows the input x

```
* what happens when you call `foo.bar(x: 10)`?
* I think the input should take precedence
* because once you complete the input, it disappears and you can access the `x` property

### Dynamic Functions and Inputs II

* I realized for the `negMath` example, you can be a lot more explicit

```js
negMath:
	negate: a => -a
	subtract: x y => x + negate(y)
;
```

* so in `subtract`, we don't even need input propagation
* because the `y` input is explicitly used in the expression
* perhaps this is better than letting inputs propagate
* you have to explicitly pass inputs into dependencies
* this makes inputs very clear

* yeah but this get's really ugly when you think about a bunch of evaluations

```js
foo: ... // inputs: x, y
	a: x+1
	b: 10+a*a
	c: b+(b/y)

	-c*(c+5)
```

* the "input" for `c` propagates backwards until it finds `x` and `y`
* we could technically write it as

```js
foo: ... // inputs: x, y
	a: x => x+1
	b: x => 10+a(x)*a(x)
	c: x y => b(x)+(b(x)/y)

	x y => -c(x,y)*(c(x,y)+5)
;
```

* but GOD DAMNNN that is ugly
* so I do think input propagation is necessary

* however, it is important to note that this method can be used to explicitly declare arguments, and force an argument order
* also stops input-search propagation

```js
foo: ... // inputs: x, y
	a: x => x+1
	b: x => 10+a*a
	c: x y => b+(b/y)

	m n => -c(m n)*(c(m n)+5) // input is m and n. Halts input-search. Any function that references foo will only see inputs m and n, nothing about x y a b or c
;
```

### Binding and List Values

* now that we aren't creating a function scope
* we don't really have to think about "unbound expressions"
* and we don't have to worry about "which operators are evaluated, and which aren't?"
	* from section "Function Extraction"
* this also helps answer how the `...(   )` syntax should work

* `...` doesn't do anything special besides map between unbound symbols and list values
* binding arguments to inputs does the same thing
* we can think about it as simply

```js
a, b, c: ...
	x+y
	10
	Math.sqrt(y)

// is the same as

temp:
	0: x+y
	1: 10
	2: Math.sqrt(y)
a: temp[0]
b: temp[1]
c: temp[2]
```

* you can think of `...` as an un-evaluated function, or you can think of it as evaluated from the start, doesn't matter
* notice that input propagation is necessary to make it work as it should
* there are no special evaluation rules for "hanging values"
* evaluation works the same for all properties, including list values

### Input Propagation and Accessor Pattern

* note that accessor pattern, and other similar behavior, only works because of input propagation
* going back to the canonical `map` example that has given me so many problems

```js
list: mylist =>
	map: fn =>
		for item in mylist:
			resultList.push(fn(item).result)

map(x => result: (x+10)/(x-10))
;
```

* notice that in function call `fn(item)`, the input is passed to the `+` operator in the `x+10` and `x-10` expression
* also notice that the function output, aka the object called, is the `/` operator in the expression
* these are not the same objects
* any time the input is passed into an object that is not the same as the output object, there is input propagation going on

### Functions vs Objects Summary

* functions and objects are the same thing
* implicit declarations for unbound symbols
	"Scope Passing and Nested Modules"
* every object can also be considered a function output
* every object has two parts:
	* properties
	* inputs
* properties are self-explanatory
* inputs are unbound symbols that are relevant to the computation of the object
	* inputs are dynamically found by traversing backwards from the object
* when "calling" an object, you can both give inputs, and override properties
	* input takes precedence
* binding and `...` is just shorthand for binding list values
	* list values are still just properties

in summary:

1. objects = functions
	* every object is a function output
2. incomplete = complete
	* every object can be complete in some ways, and incomplete in others
3. calling = cloning
	* you can give inputs and override properties at the same time
4. inputs != properties
	* inputs propagate, properties don't

-------------------------------

nice thing about accepting objects as keys
	you can implement your own hashing function
	(in nylo, it used his hashing function)
	but what if you wanted to make a custom one
	maybe like the method python uses for multidimensional arrays

error codes
	everything is a node
	so even `undefined` can have tags

`self` vs `here`, scope vs inheritance (for brackets without a target)

arguments from different places (without cloning or currying)?
	split up module definitions?

```js
foo:
	x: 10
foo:
	y: 20
```

or perhaps we have to use state variables for this, and each new definition is actually a modification

how to make default variable names?
	eg, for reduce, if not given a variable name, automatically uses item
	`reduce(list, {item -> item*2}`, but if given a variable name, uses that, and frees up "item", `for list: x -> x*2`
	or perhaps, you just have to deal with `item` in the namespace
	or maybe there's a way so, when defining the function, you can either choose to inherit the namespace (dynamic scoping)
	or you can choose to define all your own variable names


shouldn't arrows automatically imply an object? so we don't have to keep doing stuff like `map({x -> x*x})`, and just do `map(x -> x*x)`
