
### Structure

```js
root = {
	repeaters: [ {template, container}, ... ],
	listeners: [ {template, elem, property}, ... ],
	value: {
		key1: {
			repeaters: [...],
			listeners: [...],
			value: "hello"
		},
		key2: {
			repeaters: [...],
			listeners: [...],
			value: {
				subkey1: {...},
			},
		},
		mArray: {
			repeaters: [...],
			listeners: [...],
			value: {
				0: {...},
				1: {...},
				2: {...},
			},
		},
	},
};
```

Wijits
-------

### handlebars
```html
<div>{{foo}}</div>
```
* events:
	* #updated
		* default listeners: render()
* triggers
	* set() -> #updated
* attach more listeners using `<div updated="myListener">{{foo}}</div>`, and `scope.myListener()` will be called when update is triggered
* if your listener contains the call `this.preventDefault()`, it will prevent the default listener from being triggered (in this case, `render()`)

### list wijit
```html
<repeat items="index, item in items">
	<div>{{index}}: {{item}}</div>
</repeat>
```
* events:
	* #item_changed
	* #index_changed
* triggers:
	* set() -> #item_changed
	* insert(), remove() -> #index_changed
* if an item is inserted to beginning of the list, then everything after gets its index changed
	* each event will cause the entire element to re-render!
	* thats a lot of rendering!! pretty expensive
* thus, check if there are any #index_changed listeners in the first place, before sending out all the events
* this should generalize to all events. For example, if there are no #item_changed listeners, no need to send out any events after set()

### selection wijit
```html
<selection items="item, isSelected in items" selection="selection" onselectionchanged="onselectchanged">
	<div class="{{isSelected}}">{{item}}</div>
</selection>
```
* events
	* #item_changed
	* #item_selected
	* #selection_changed
* triggers
	* select() -> #item_selected, #selection_changed
* note that isSelected is NOT a property of item
	* "item" is a data structure defined by the user, we don't wanna restrict them with reserved properties
	* instead, we have a mirror array specifically for properties like these

Scopes
------

* for things like the listwijit, that declare new variable names, I suspected that I would need to start dealing with creating new scopes and such
* originally, my simple solution was to replace the new variable names with their absolute path
* for example, if I had this (assuming `items` and `foo` are already declared in the root scope)

```html
<repeat items="item in items">
	<p>{{item}} hello {{foo}}</p>
</repeat>
```
* I could render it as something like this

```html
<container>
	<p>{{items.0}} hello {{foo}}</p>
	<p>{{items.1}} hello {{foo}}</p>
	<p>{{items.2}} hello {{foo}}</p>
	etc...
</container>
```
* problem with this is that if I inserted an item at say, index 0, then all the items get their absolute path changed
* another tempting solution is to walk up the tree to find the first match
	* {{item}} will walk up all the way till the repeat wijit, where it finds a match
	* {{foo}} will walk all the way up till the root scope
* problem is when you have something like this

```html
<repeat items="item in [5,10,15]">
	<p>{{item}} hello {{foo}}</p>
</repeat>
```
* now the scope of the repeat wijit is completely separate from the root scope
* thus, whenever we create a new scope we need to explicitly hold onto a reference to the parent scope
* analagous to this

```js
repeat(items, function (item) {
	return handlebars(item + foo);
})
```
* more on scopes further down

Data vs Function-Based
------------------------

* should I make it more like angular, where I directly modify data and the widgets "listen" to the data and change on their own
	* allows me to attach multiple different widgets to the same piece of data
or should I make it more function-based, where widgets have an API and an internal piece of data, and you call the widget's API to modify the data
	* more object oriented, like `selectList[4].select()` instead of `selectList[4].isSelected = true;`
	* this makes sense with the "repeat" wijit, where you would have common array operations like "push" and "splice"
	* however, this means that I can only have one type of widget attached to a piece of data, otherwise the different APIs might clash
* example: music player

### Angular
```html
<repeat for="song in songs">
	<img src="song.cover"></img>
	<button onclick="play(song)">{{song == currentlyPlaying && song.playing ? pause : play}}</button>
	<p>{{song.title}}</p>
</repeat>
<script>
var songs = retrieveSongs();
var currentlyPlaying;

function play (song) {
	if (currentlyPlaying == song) {
		if (song.playing) {
			audioPlayer.pause();
			song.playing = false;
		} else {
			audioPlayer.resume();
			song.playing = true;
		}
	} else {
		audioPlayer.play(song.src);
		currentlyPlaying = song;
		song.playing = true;
	}
}
</script>
```

### Function Based
```html
<template name="song">
	<img src="cover"></img>
	<button onclick="events.play">{{playing ? pause : play}}</button>
	<p>{{title}}</p>
	<script>
	setPlaying = function (bool) {
		this.playing = bool;
	}
	</script>
</template>
<songlist for="song in songs">
	<song data="song" onplay="play(song)"></song>
</songlist>
<script>
scope.songs.setAll(retrieveSongs());

scope.play = function (song) {
	if (currentlyPlaying == song) {
		if (song.playing) {
			audioPlayer.pause();
			song.setPlaying(false);
		} else {
			audioPlayer.resume();
			song.setPlaying(true);
		}
	} else {
		if (currentlyPlaying) {
			currentlyPlaying.setPlaying(false);
		}
		audioPlayer.play(song.src);
		currentlyPlaying = song;
		song.setPlaying(true);
	}
}
</script>
```

Wijit Model
-------------

```html
<wijit name="song">
	<img src="{{cover}}"></img>
	<button onclick="{{onplay}}">{{active && playing ? pause : play}}</button>
	<p>{{title}}</p>
</wijit>
<repeat for="song in songs">
	<song data="song" active="song.src == audioPlayer.src" playing="audioPlayer.playing" onplay="(e) => play(song, e)"></song>
</repeat>
<script>
audioPlayer = {
	states: { loading, loaded, finished, error },
	playing: false,
	currentTime,
	src,

	play: function (src) {
		this.src = src;
		state = loading;
	},

	restart: function () {
		this.currentTime = 0;
		state = loaded;
		playing = true;
	},
}

songs = retrieveSongs();

function play (song, e) {
	if (song.active && song.state !== error) {
		if (song.state == finished) audioPlayer.restart();
		else audioPlayer.playing = !audioPlayer.playing;
	} else {
		audioPlayer.play(song.src);
	}
}
</script>
```

* originally I was writing array functions into the repeat wijit, like push() and insert()
* this way I could trigger the correct element listeners after modifying the underlying array
* also considered having <repeat> wijit like a library api, where you would pass in the array to modify, eg instead of push(item), do push(array, item)
	* this way the array wasn't "internal" to the <repeat> wijit, and multiple wijits could bind to one array
	* if other types of wijits wanted to use the push function, they could borrow the function: RepeatWijit.push.call(this, array, item)

* in the end, its not whether or not it should be data based or function based, everything has data and functions
* but for wijits, data is in the form of states, and functions are in the form of state transitions
* for the underlying data structures, data is just data, while functions are used for transforming the data
* the <repeat> wijit shouldn't have the push() or splice() functions because that is something inherent to the Array data structure
	* something only the Array data structure should have control over
* <repeat> wijit can attach listeners to the push() or splice() events to respond accordingly
* the <repeat> wijit can still respond to user events and modify the underlying Array, but it has to do so through the Array's transformation api

### Wijit Binding

* notice the `active="song.src == audioPlayer.src"` wiring, kind of like how in verilog you can do

```
SongModule song0 (
	.data (song),
	.active (song.src == audioPlayer.src),
	.playing (audioPlayer.playing),
	.onplay (play),
);
```

* `onclick="{{onplay}}"` declaring an outgoing event, and `onplay="(e) => play(song, e)"` is where it is bound
	* yeah I know arrow functions are for ES6, but it makes it way more concise
	* there's really nothing special going on here, "onplay" is just a property of song, so onclick calls song.onplay(e)
* note that handlebars are only needed with default html tags, and are implied in wijits

### Bind Expressions

```js
scope.bind([scope.var1, scope.var2], function () {
	scope.x = scope.var1 + scope.var2;
})
```
* this example will bind the result of `scope.var1 + scope.var2` to `scope.x`
* syntax for bind function: `bind(result_variable, [trigger_variables], evaluator)`
* all wijits internally use these bind expressions
* `<div>{{foo}}</div>` is just a special bind expression that, instead of setting a variable, sets the innerHTML of an element

shorthand:

```js
scope.bind('x = var1+var2');
```
* right hand side must be simple expression (single statement of words and operators, no "," or ";" or "function")
* also no function calls, because we can't determine which variables to watch from that (use long-form bind to manually specify trigger variables)
* take out left-hand-side -> "var1+var2"
* find all variables that consist of just letters and "."s: `[\w.]*`

dynamic trigger variables:

* problem: "x = a[b+c]", we shouldn't be watching if `a` changes, we have to watch if `a[b+c]` changes
* `a[b+c]` defines the trigger variable
* when it changes, we need to rebind this expression
	* remove listener from old trigger variable
	* attach to new trigger variable
* this is a bit complicated, so I won't allow `[]` characters in bind expressions for now

### Scopes and Binding

* so we don't have to explicitly hold onto each scope and variable name, we let javascript closures do the work for us

```js
function parse (scope, elem) {
	triggerVars = [];
	expression = elem.innerHTML.replace(/[\w.]+/g, function (match) {
		if (!match[0] || !isNaN(match[0])) return match; // skip names that start with a number (invalid)
		triggerVars.push(match); // add name to triggers
		return 'scope.' + match; // prepend "scope." to all variable names
	});
	var evaluator = eval('(function () { elem.innerHTML = ' + expression + ';})'); // enclose expression in a function, capturing the scope at the same time
	scope.bind(triggerVars, evaluator);
}
```

* when you need to create new scopes

```js
function parseRepeater (scope, container, template) {
	var repeatExpr = container.repeat.split(' in '), // given expression "item in items"
		data = scope[repeatExpr[0]],
		alias = repeatExpr[1]; // data: scope["items"], alias: "item"

	data.forEach(function (item) {
		var extendedScope = Object.create(scope); // create a new scope off the parent scope
		extendedScope[alias] = item; // add the extra "item" variable
		var elem = template.clone();
		parse(extendedScope, elem); // parse will create the listeners with the new scope, and bind listeners to the new element
		container.append(elem);
	});
}
```

* the function enclosure inside the `eval()` is the key to everything
	* pre-compiles the expression, which has [up to 18x performance benefits](http://jsperf.com/eval-vs-pre-compiled/4)
	* evaluates the expression for us so I don't have to make my own expression parser
	* holds onto the scope so I don't have to manually store a reference to it
	* leverages javascript's built in closure and scope mechanisms, ensuring consistency between my framework and doing everything in vanilla js

### Binders

* originally I was gonna try to leverage the `bind("x = a+b")` function for binding elements
* issue: different method signatures:
	* `bind (scope, 'x = a+b') => scope.x = scope.a + scope.b`
	* `bindElem (scope, '{{a+b}}', elem) => elem.innerHTML = scope.a + scope.b`
	* the left-hand side of bind() is within the scope, while bindElem() is not
	* maybe there's a way to coax one of the functions to look like other?
* realized that bind() and bindElem() do fundamentally different things
* bind() is meant for binding data together within the same scope
* bindElem() is meant for binding data between the app scope and the element scope
* thus, while the syntax is similar now, the syntax can diverge at any time, so bind() and bindElem() should be kept separate
* wijits and manual bind() expressions all are types of **binders**
* binders are responsible for maintaining data bindings
* internal binders like bind() expressions are for binding data within the same scope
* binders like bindElem() are for binding data across scopes
	* eg: a database binder that updates the database when the user changes data in the app
* wijits create new scopes and bind to the parent scope
* ultimately the wijit tree leads to elemwijits, special wijits that use bindElem() to bind directly to a DOM element

### Tracking Array Index

* say you have a repeater that keeps track of index
	`<repeat for="item,index in array">`
* should the index be handled by the array data structure, or the repeat wijit?
	* data structure: wrap item and index in a container `{ item: ..., index: ...}`
		* array stores these containers, not the items directly
		* when index of a container changes, container.index property updated to match
	* repeat: keep an array of all the extendedScopes, store an `index` property in each of these extended scopes
		* update affected extendedScopes.index properties when recieving #oninsert, #onremove events
* the problem with handling it in the array structure is that we have this indirect wrapper structure going on
* the problem with handling it in repeater, is if we have another wijit that wants to use indexes, we have to reimplement all the index updating functions when receiving #oninsert and #onremove
* SOLUTION:
* note that index is not a part of the item
* array uses it internally to get/set items, but the item itself is detached
* for this specific repeater, we want each item to contain both the item and the index
* use a special array that wraps the item and index
* thus, its not handled by the array structure or the repeat wijit, but a new data structure entirely

### Deep Property Binding

* `x = a.a.a`
* this can be seen as `x = a.get('a').get('a')`
* three ways to handle this
	* keep as one binding, with three triggers `[a, a.a, a.a.a]`
	* separate into two bindings `temp = a.get('a')`, `x = temp.get('a')` with two triggers each
	* one binding, one trigger `a.a.a`, but when triggering listeners, search the tree to trigger all child listeners too
		* eg if we have `x = {a: {a: 3}, b: 2 }`, and we set `x`, then trigger listeners for `x`, `x.a`, `x.a.a`, `x.b`

### Collection Listeners

* ignoring efficiency, whats the simplest collection listener?
	* if we start with `map = {a: 1, b: 2}`, and a collection listener `for key,val in map => map2[key] = val+1`
	* initially the collection listener creates 2 value listeners, `map2.a = map.a+1`, `map2.b = map.b+1`
	* set `map.b = 3` => value listener changes `map2.b`
	* set `map.c = 4` => collection listener notices keyset changes, destroys old `map2` and all value listeners, then re-evaluates entire collection to create 3 value listeners
* what about arrays?
* if we do `['a','b','c'].shift('x')`:
	* item 0 changes to 'x', item 1 changes to 'a', item 2 changes to 'b', item 3 changes (from undefined) to 'c', and length changes to '4'

### Separating Definitions from Data, Bindings from Values

* binding should happen at the definition level, not the data/value level
	* if we bound listeners to data/values:
		* say we bind `x = a.a.a` => `a = {a: {a: 5, _listeners: ["x = a.a.a"] }}`
		* then if we set `bla = a.a.a`, `bla` would inherit the listeners
		* in addition, if we set `a.a.a = 10`, then we would lose the listeners
* I already separated the listeners from the value at the tip level
	* `x = {listeners[], value}`, if you change x value, don't have to rebind the listener
* however, for `x = a.a.a`, if you set `a = {a: {a: 5}}`, have to rebind listeners for `a.a` and `a.a.a`
* thus, we need to completely separate the bindings tree from the value tree
* when setting a value:
	* set the value in the value tree
	* follow the same path in the bindings tree to retrieve the evaluators and run them
		* make sure to trigger any collection listeners directly above the path, eg `a.a.a = 5` will trigger collection listeners on `a.a`
	* this process is recursive; evaluators will set a value, which can trigger more evaluators

```js
a = {a: {a: 4}};
b = 11;
x = a.a.a; //binding 1
y = x+b; //binding 2
z = a.a*b; // binding 3
```
will result in:

```js
// eval1: (x = a.a.a), eval2: (y = x+b), eval3: (z = a.a*b)
bindings: { "a": [eval1], "a.a": [eval1, eval3], "a.a.a": [eval1], "b": [eval2, eval3], "x": [eval2] }
values: { a: {a: {a: 4} }, b: 11, x: 4, y: 15, z: 44}
```

### Event Listeners for Optimization, Re-evaluation by default

* bindings work purely on the current state of the data, regardless of the operations used to get to that state
* when the data changes, we simply re-evaluate the expression
* this is why my previous idea in "Tracking Array Index" with registering #oninsert and #onremove listeners is wrong
	* also my current implementation of ReactiveArray sends #onpush events to update listeners, which is also wrong
* listeners should not have to implement an interface or listen to events. This part is data based, not function based
* note that events can be used to optimize the re-evaluation

ReactiveArray.splice(4,2,["a"]) => onsplice
	ReactiveArray.remove(4,2) => onremove
		ReactiveArray.removeOne(4) => onremoveOne
		ReactiveArray.removeOne(4) => onremoveOne
	ReactiveArray.insert(4,["a"]) => oninsert
		ReactiveArray.insertOne(4,"a") => oninsertOne

* lets say this ReactiveArray has 3 listeners:
	* listener 1: implements onsplice
		* absorbs the #onsplice event, and is not called for subsequent events
	* listener 2: implements onremoveOne and oninsert
		* absorbs two #onremoveOne events and one #oninsert event
	* listener 3: implements onremove
		* can absorb the onremove tree but not the oninsert tree, default to re-evaluation

* a binding should always be able to default back to re-evaluating the expression
* note that setting a just one property can trigger a complete re-evaluation
* originally, in my repeat wijit, modifying one property just affected the corresponding item element
* however, that won't work for something like a summation function: `array => array.reduce((sum, item) => sum+item, 0)`
	* no #onset listeners so defaults to re-evaluation
* on the other hand, operations like map() can automatically generate #onset listeners

```js
bind('squared = array.map(x => x*x)');
// results in
var mapFn = (x => x*x)
evaluator = () => { scope.squared = scope.array.map(mapFn) }
evaluator.onset = (key, value) => { scope.squared[key] = mapFn(value) }
```

* map binds can also use item-to-item bindings in place of onset (which is how the repeat wijit works)

```js
bind('squared = array.map(x => x*x)');
// results in
var mapFn = (x => x*x)
evaluator = () => { scope.array.forEach(evaluator.onpush) } // use onpush to create item-to-item bindings between scope.array and scope.squared
evaluator.onset = () => true // don't do anything
evaluator.onpush = (value, index) => { scope.squared.push(value); scope.bind('squared['+index+'] = mapFn(scope.array['+index+']') }
```

### ReactiveArrays

* note that if we use an internal array and use array operations, we have to make sure to manually call listeners
* eg, ReactiveArray([1,2,3,4,5]).splice(2, 0, "x") has to both update any array/collection listeners, but also call value listeners for each array item after (and including) index 2

### Proxies and getters/setters

* use `defineProperty` to override get()/set() so you can use normal assignment notation while still triggering the listeners

```js
function createProxy(obj, prop) {
	var value = obj[prop];

	Object.defineProperty(obj, prop, {
		get: function () {
			return value;
		},
		set: function (newValue) {
			value = newValue;
			// call all listeners
			obj._listeners[prop].forEach(function (listener) { listener(); });
		},
		enumerable: true,
		configurable: true
	});
}

var test = {a: 10}; // not proxied yet
createProxy(test, 'a');
test.a = 5; // proxied, calls listeners
```

* during the bind() function, we can extract the trigger variable names and proxy them
* however, note that because we have to proxy one by one, we can't dynamically proxy every item in a collection
* thus, collections listeners won't be able to detect when new properties are added
* good try pupper

### Pre-parsing

* because proxies won't work, perhaps we can do pre-parsing
* all wijit script tags are within a `<template>`, so they won't automatically be run
* before running a wijit script, find all assignments and replace them with set()
* eg `scope.a = "hi"` => `scope._set('a', "hi")`
* make sure that set() returns the result to account for expressions like `var x = (scope.x = 5)` => `var x = (scope._set('x', 5))`
* a possible issue with this is finding where to close the parenthesis
* perhaps we can replace the assignments with proxies
* eg `scope.x = "hi"` => `scope._proxy('x').$ = "hi"`

```js
scope._proxy = function (path) {
	return {
		set $ (val) {
			return scope._set(path, val);
		}
	};
};
```

### Deep Property Binding Revisited

* consider a simple assignment, `foomirror = foo`
* due to javascript's reference-based model is that, if foo.x changes, bar.x will change too (foo and bar point to the same object)
* if foo itself changes though, bar won't, because now foo and bar point to different things
* our binding mechanism fixes this, and mirrors changes at the base level:
* however, while the reference-based model seems like a blessing, mirroring changes above the base level, this is actually a problem because it _silently_ mirrors changes
* for example, if we bind `x = foomirror.x`, and we change `foo.x`, `foomirror.x` changes without the binding mechanism knowing about it, and `x` won't be updated
* to fix this, when changing a value, don't just trigger the listeners on that value, trigger the listeners on any ancestors of that value as well
	* we also trigger the listeners on any descendents too, as noted in the "Deep Property Binding" section
* if "x" marks the set value, "a" marks every affected node

	       a
	      / \
	     a   .
	    / \   \
	   .   x   .
	      / \
	     a   a

* tbh, this makes perfect sense. if foo.x changes, that means foo changed as well
* but what about collection listeners?

* consider if we bind `bar.x = foo`, and the later bind `bar = foo`
* this gives `bar.x` a double binding, because the binding `bar = foo` will also determine `bar.x`, BAD!!
* to fix all these issues, we force all binding results to be at the root level
* this also prevents multiple ways of defining identical bindings, which could happen before:
	* `bind(x = {a: foo, b: bar})` == `x = {}; bind(x.a = foo); bind(x.b = bar)`
* this also prevents mixed items, where some properties are bound and some aren't, eg `x = {a: 0}; bind(x.b = foo)`
* in fact, all bindings should belong in a separate domain entirely

```
module songelem (song, audioPlayer) {
	active: (song.src == audioPlayer.src)
	playing: audioPlayer.playing
} (active, playing)
```

* this also ensures that all bindings happen at once, at the beginning
	* if a binding didn't happen at the beginning, then the period of time which it was unbound will likely lead to unexpected behavior
* note that bound variables can't really be used in functional code, but functional code can be used to change bound variables

### Collection Listeners Revisited

* don't item-to-item bindings also create double bindings?
* they also won't be at the root level
* collection bindings actually are for defining collections of bindings, not just for binding collections
	* thus, the "reduce" function discussed in the "Collection Listeners" section is not actually a collection binding!
* collection bindings determine how and when to create/destroy bindings, and create a structure to store the values
* the bindings themselves determine the values
* that way there's no conflict of interest
* the bindings they create "belong" to the collection
* collection bindings are bindings themselves, so they can create recursive structures, like a 2d matrix bind

```js
function songlist (songs, audioPlayer) {
	songelem: function (song) {
		active: (song.src == audioPlayer.src)
		playing: audioPlayer.playing
	}
	elems: songs.map(songelem) // collection bind. if a single song changes, then the corresponding _songelem changes, nothing else
}
```

* a normal mirror bind, `bar = foo`, is also a collection bind!
	* in a value-based model, this would be a vital optimization
		* if `foo.x.x.x` changes, then we should only update `bar.x.x.x` and all it's subvalues
	* in a reference-based model, the optimization is unneeded

### Reference Based Models

* its important to note that binding makes the most sense in a value-based model
* a reference based model is useful for passing around data structures, which doesn't really happen in data binding
* reference based models are also useful for copying data structures
* in some ways, reference based model may seem like they have inherent data-binding

```js
var foo = [5];
var bar = foo;
foo[0] = 10;
console.log(bar[0]); // outputs 10
```

* however, this only works because we are copying values
* if we added any transformations, this would not work, and the distinction between reference-based models and data-binding becomes clear

```js
var foo = [5];
var bar = foo.map(x => x*x)
foo[0] = 10;
console.log(bar[0]); // outputs 25, not 100
```

* thus, pass-by-reference is merely an optimization, and when thinking about data-binding, it's useful to assume a pass-by-value model

### Defining Collection Binds and Functional Programming

* functional programming is optimal for defining collection binds because functional programming never modifies or moves around data
* likewise, it doesn't make sense to modify or move a binding (note: dynamic bindings do move around, but that's a weird exception)

```js
function concat (list1, list2) {
	var res = new Array(list1.length + list2.length)
	for (var i = 0; i < res.length; i++) {
		res[i] = (i < list1.length) list1[i] : list2[i-list1.length] // bind the beginning to list1, and the rest to list2
	}
	return res
}
function flatten (tree) {
	if (!tree.length) return tree; // either an empty list or a value
	var last = tree.last();
	return concat( flatten(tree.slice(0, tree.length-1)), flatten(last) )
}
```
