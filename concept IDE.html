<html>

<head>
<style>
	.textarea-container {
		position: relative;
	}

	textarea {
		width: 80%;
		height: 80%;
		line-height: 1;
		font-size: 20px;
	}

	.unbound-symbols {
		position: absolute;
		z-index: 10;
	}
</style>
</head>

<body ng-app="MyApp" ng-controller="MyCtrl">

	<h1>{{title}}</h1>
	<br>
	<br>
	<div id="ide" class="textarea-container">
		<textarea ng-model="code" ng-change="interpret($event)"></textarea>
	</div>
	<script src="angular.min.js"></script>

<script>
var ideContainer = document.getElementById('ide');
var IDE_FONT_SIZE = 20;
var IDE_LINE_HEIGHT = IDE_FONT_SIZE;

angular.module('MyApp', [])
.controller('MyCtrl', function($scope) {
	$scope.title = 'Concept IDE';

	$scope.graph = {};
	var rawtree = {properties: [], values: [], scope: {}};

	// start with some test cases
	$scope.code = `
outer:
	test: hello
	blaa
	nested:
		10, test

	foo(x: 10)
	`;

	$scope.interpret = function (event) {
		console.log('--------- Begin Parse --------');
		parse($scope.code);
		findUnboundSymbols(rawtree);
		displayUnboundSymbols();
	};

	function parse (code) {
		var currentDepth = 0;
		var currentNode = rawtree;
		code.split('\n').forEach((line, lineNum) => {
			if (/^\s*$/.test(line)) return; // skip blank lines

			var regexResults; // used throughout for regex results

			regexResults = line.match(/^(\t+)?(.*)/);
			var indentation = (regexResults[1] || '').length;
			line = regexResults[2];

			var key = '';
			regexResults = line.match(/^(\w+):(.*)/);
			if (regexResults) {
				key = regexResults[1];
				line = regexResults[2]
			}

			// note: this regex doesn't account for parenthesis
			// explanation of `source`: for something like foo(1,2), the value is {1,2} and foo is the source
			var values = (line.match(/\w+/g) || []).map(x => ({value: x, lineNum, source: null}));

			while (indentation < currentDepth) {
				currentNode = currentNode.parent;
				currentDepth--;
			}

			if (key) { // if we have a key, we start building a nested object
				var newNode = {key, values, lineNum, properties: [], parent: currentNode,
						scope: Object.create(currentNode.scope)}; // leverage javascript inheritance for scopes

				currentNode.properties.push(newNode);
				currentNode.scope[key] = true;
				currentNode = newNode;
				currentDepth++; // if there is a key, we increase our depth
			} else {
				currentNode.values.push(...values);
			}

			// console.log('indentation: ' + indentation + ', key: ' + key + ', values: ' + values.map(x => x.value));
		});

		console.log(rawtree);
	}

	// given a scope of defined symbols, finds all unbounds symbols used in a module
	function findUnboundSymbols(node) {
		node.unbound = node.values.filter(x => !node.scope[x.value]);
		node.properties.forEach(prop => findUnboundSymbols(prop));
	}

	function displayUnboundSymbols() {
		var displayText = document.createElement('div');
		displayText.innerHTML = ['hello','world'].toString();
		displayText.classList.add('unbound-symbols');
		displayText.style.fontSize = IDE_FONT_SIZE;
		displayText.style.top = 3*IDE_LINE_HEIGHT;
		displayText.style.left = 30;

		ideContainer.appendChild(displayText);
	}

	$scope.interpret(); // interpret initial textarea (before any changes)
});
</script>

</body>

</html>
