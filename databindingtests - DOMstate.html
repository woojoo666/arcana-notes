<html>

<body>
	<h1>{{title}}</h1>
	<p>{{description}}</p>
	<ul>
		<li>{{test1results}}</li>
		<li>{{test2results}}</li>
		<li>{{test3results}}</li>
	</ul>
	<br>
	<br>
	<ul>
		<li>{{li1}}</li>
		<li>{{li2}}</li>
		<li>{{li3}}</li>
		<li>{{li4}}</li>
		<li>{{li5}}</li>
		<li>{{li6}}</li>
		<li>{{li7}}</li>
		<li>{{li8}}</li>
		<li>{{li9}}</li>
		<li>{{li10}}</li>
		<li>{{li11}}</li>
		<li>{{li12}}</li>
		<li>{{li13}}</li>
		<li>{{li14}}</li>
		<li>{{li15}}</li>
	</ul>
<!-- 	<div class="repeat" data-array="item in ar" style="border: 2px solid grey; display: inline-block; padding: 5px; margin: 5px;">
		<span>hi</span>
		<button>{{item}}</button>
	</div> -->
	<button onclick="start();">{{buttonTitle}}</button>
	<script>

	/*
	 *	Structure:
	 *
	 *	root = {
	 *		repeaters: [ {template, container}, ... ],
	 *		listeners: [ {template, elem, property}, ... ],
	 *		value: {
	 *			key1: {
	 *				repeaters: [...],
	 *				listeners: [...],
	 *				value: "hello"
	 *			},
	 *			key2: {
	 *				repeaters: [...],
	 *				listeners: [...],
	 *				value: {
	 *					subkey1: {...},
	 *				},
	 *			},
	 *			mArray: {
	 *				repeaters: [...],
	 *				listeners: [...],
	 *				value: {
	 *					0: {...},
	 *					1: {...},
	 *					2: {...},
	 *				},
	 *			},
	 *		},
	 *	};
	 */

	DOMstate = {
		root: {},
		handlebarsMatcher: /\{\{([\.\w]+)\}\}/g, // allow for '.' to delimit keys
		getScope: function (path, parentscope) {
			if (!parentscope) parentscope = this.root;
			if (!path) return parentscope;

			return (function getNestedValue (keys, obj) {
				if (keys.length <= 0) return obj;
				var head = keys.shift();
				obj = obj.value || (obj.value = {});
				return getNestedValue(keys, obj[head] || (obj[head] = {}));
			})(path.split('.'), parentscope);
		},
		get: function (path, scope) {
			return this.getScope(path, scope).value;
		},
		getListeners: function (path, parentscope) {
			var scope = this.getScope(path, parentscope);
			return scope.listeners || (scope.listeners = []);
		},
		getRepeaters: function (path, parentscope) {
			var scope = this.getScope(path, parentscope);
			return scope.repeaters || (scope.repeaters = []);
		},
		parse: function (rootelement) {
			var self = this;
			var elements = rootelement.getElementsByTagName('*');

			for (var i = 0; i < elements.length; i++) {
				var elem = elements[i];

				if (elem.classList.contains('repeat')) {
					this.parseRepeat(elem);
					// TODO: how do I skip all elements created and handled by parseRepeat?
					continue;
				}

				if (elem.firstElementChild || elem.tagName == "SCRIPT") continue;
				// element is a plaintext node
				if (elem.innerHTML.indexOf('{{') < 0) continue; // no handlebars

				this.bindElem(this.root, elem);
			}
		},
		parseRepeat: function (elem) {
			var container = document.createElement('div');
			elem.parentNode.insertBefore(container, elem);
			elem.remove();

			var match = elem.dataset.array.match(/(\w+)\s+in\s+(\w+)/);
			var subscopeAlias = match[1];
			var path = match[2];
			this.getRepeaters(path).push({ container: container, template: elem, subscopeAlias: subscopeAlias });

			var initialArray = this.get(path);
			if (initialArray) this.arrayOp(key).setAll(initialArray);
		},
		bindElem: function (scope, elem) {
			triggers = [];
			var expression = elem.innerHTML.match(/\{\{(.*)\}\}/)[1];
			var self = this;

			expression = expression.replace(/[\w.]+/g, function (match) {
				if (!match[0] || !isNaN(match[0])) return match; // skip names that start with a number (invalid)
				triggers.push(self.getScope(match, scope)); // add match to triggers
				return 'self.get(\"' + match + '\",scope)'; // prepend "scope." to all variable names
			});
			assignFn = eval('(function () { elem.innerHTML = ' + expression + '; })');

			for (var i = 0; i < triggers.length; i++) {
				this.getListeners(null, triggers[i]).push(assignFn);
			}
			assignFn(); // call it once
		},
		set: function (path, value, parentscope) {
			var scope = this.getScope(path, parentscope);
			scope.value = value;
			var listeners = this.getListeners(null, scope);
			for (var i = 0; i < listeners.length; i++)
				listeners[i]();
			return this; // for chaining
		},
		arrayOp: function(path) {
			var scope = this.getScope(path);
			var repeaters = this.getRepeaters(path);
			var parentThis = this;

			return {
				clear: function () {
					for (var i = 0; i < repeaters.length; i++) {
						var repeater = repeaters[i];
						var container = repeater.container;
						while (container.firstChild) {
							container.removeChild(container.firstChild);
						}
					}
					scope.value = [];
				},
				setAll: function (array) {
					this.clear();
					for (var i = 0; i < array.length; i++) {
						this.push(array[i]);
					}
				},
				getPath: function (index) {
					return path + '.' + index;
				},
				set: function (index, value) {
					if (index >= scope.value.length) {
						console.log("index out of bounds");
						return;
					}

					parentThis.set(this.getPath(index), value);
					return this; // for chaining
				},
				render: function (repeater, index) {
					var elem = repeater.template.cloneNode(true);
					var path = this.getPath(index);
					var matcher = new RegExp('(\\{\\{(?:[^{}]*[^.\\w])?)' + repeater.subscopeAlias + '(?!\\w)([^{}]*\\}\\})', 'g');
					// replace {{$subscopeAlias}} with {{$arrayPath.$index}} so it gets parsed like any other subscope
					elem.innerHTML = elem.innerHTML.replace(matcher, '$1'+path+'$2');
					return elem;
				},
				push: function (value) {
					scope.value.push({value: value});
					var index = scope.value.length-1;

					for (var i = 0; i < repeaters.length; i++) {
						var elem = this.render(repeaters[i], index);
						parentThis.parse(elem);
						repeaters[i].container.appendChild(elem);
					}
				},
				pop: function () {

				},
				remove: function (value) {

				},
			};
		},
	};

	DOMstate.parse(document.body);

	DOMstate.set('title','Comparing Data-Binding Methods: DOMstate (listeners)');
	DOMstate.set('description','Angular uses polling to update the elements, while DOMstate uses listeners. Supposedly, DOMstate should use less memory while idle because it doesn\'t continuously poll the data for changes, which Angular calls its \"digest\" loop. According to my tests, Angular used about 17k while DOMstate used about 13k. Randomizing the numbers (using the \"randomize!!\" button) doesn\'t really change memory usage for either method. Note that Angular\'s ng-repeat has a reputation for being slow, so I did 3 tests (making sure to restart the browser before each test to clear the cache!). Notice how DOMstate\'s memory barely increases (because it is actually idle), while Angular\'s increases marginally (because the polling loop gets slower). The difference is noticable, but really not significant (only 4k more memory used at 1000 repeats).');
	DOMstate.set('test1results','No repeat: Angular - 16k, DOMstate - 15k');
	DOMstate.set('test2results','100 repeats: Angular - 17k, DOMstate - 15k');
	DOMstate.set('test3results','1000 repeats: Angular - 21k, DOMstate - 17k');

	DOMstate.set('li1','test 1');
	DOMstate.set('li2','test 2');
	DOMstate.set('li3','test 3');
	DOMstate.set('li4','test 4');
	DOMstate.set('li5','test 5');
	DOMstate.set('li6','test 6');
	DOMstate.set('li7','test 7');
	DOMstate.set('li8','test 8');
	DOMstate.set('li9','test 9');
	DOMstate.set('li10','test 10');
	DOMstate.set('li11','test 11');
	DOMstate.set('li12','test 12');
	DOMstate.set('li13','test 13');
	DOMstate.set('li14','test 14');
	DOMstate.set('li15','test 15');

	DOMstate.arrayOp('ar').setAll([]);
	var size = 1000;
	for (var i = 0; i < size; i++) {
		DOMstate.arrayOp('ar').push(Math.floor(1000*Math.random()));
	}

	DOMstate.set('buttonTitle','Randomize!!');

	function start() {
		setInterval(function() {
			DOMstate.arrayOp('ar').set(Math.floor(size*Math.random()), Math.floor(1000*Math.random()));
		}, 50);
	}

	</script>
</body>

</html>
