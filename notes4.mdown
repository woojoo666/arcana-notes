### Random Syntax Stuff

* i forgot when I wrote these down, so some of this stuff might be outdated, but this was just syntax exploration

```js
set:
	10
	20
	30

(a, b, c) = set() // object deconstruction

sum: // a, b   <-- implicit inputs, generated by the IDE
	tag: 'hello'
	a+b

sum(
	a: 10,
	b: 20
)

Person:
	name: 'bob'


Student: Person
	occupation: 'student'

//------------------------------------------------------

outer:
	a: 10
	inner: // b
		a+b

Bob:
	name: 'bob'
	id: 21943
	age: 20

	mStudentId: studentId()
	onlineAlias: onlineAlias()



// -----------------------------------------

list
	reduce
		acc, fn
		for item in list
			acc.next: fn(acc, item)

mList: [1, 2, 3, 4]
mList.reduce(0, (acc, item, => acc+item) )
mList.reduce(0, acc+item ) // because acc and item are unbound in this scope, it's up to reduce's scope to provide values for them


Student: Person.with
	age: 22
	occupation: undefined

// ------------------------------------


stateVariable. = 0
for (reduceFn.calls):
	stateVariable++


// if we do standard imperative style

stateVariable. = 0
reduceFn:
	stateVariable++

// then we don't have control over how the reduceFn's interact and connect to eachother, versus if we do

stateVariable. = 0
for ( reduceFn.calls with nthChild(3n+1) ): // using css selector style
	stateVariable++

nthChildExample:
	for (n in naturalNumbers)
		if (3n+1 = index)
			-> true
	--> false
// right now will have overdefined anytime something is true
// we need some sort of syntax for defaults
// more discussion in this on the "Defaults" section

nthChild: {expression} // alternative syntax for arguments, it's really just creating a set and then extending it
	for (n in naturalNumbers)
		if (expression() = index) // as long as expression uses `n`, then it will be bound to the `n` in the for-loop
			-> true               // this is because of clone scoping
	--> false

```


### Arrow Operator to indicate Inputs

* instead of using the arrow operator to indicate outputs, maybe we can use it to indicate inputs

```js
foo: a, b, => // inputs/symbols
	x: "hello world"
	a+b // output

```

* recall that, back when `=>` was used for outputs, it forced us to group all our outputs onto one line/group at the end
* it actually makes more sense to use `=>` instead for inputs
* inputs are just variable names, so it's easy to group them all at the top, often on one line
* outputs can be long expressions, so forcing them on one line is annoying
* also, sometimes you might want some outputs in the middle, instead of all of them at the end

* a cool side effect of this is that, now the arrow operator works pretty much like in every other language

```js
// javascript code:
var myFn = (x, y) => x+y;
var squared = [1,2,3].map(x => x*x);

//arcana
myFn: x, y => x+y
squared: [1 2 3].map(x => x*x)
;
```

### Deeply Nested Outputs and State Variables

context: Carrying Out Deeply Nested Outputs

use state variables

```js
foo:
	x // a state variable
	a_bunch:
		of_nested:
			scopes:
				x := 20
```

### Branching II

context: Branching

recall that we were trying to find an easy to add a branch in the middle of a flow
the ugly way, that required an entire restructuring, was as follows

```js
var tablistcontainer = document.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot.getElementById("history-item-container")
tablistcontainer.appendChild(mytextarea)
var tablist = tablistcontainer.querySelectorAll(".website-title");
```

* we discussed how much easier this is in diagram-based languages
* where you can just draw connections

* text-based languages make it hard
* we could still sort of achieve this:

```js
// both values in the tuple have unbound `tablistcontainer`, which is then defined in the arguments module
// recall from the section "Implied Parenthesis" that indented blocks are implicitly treated as function arguments
(mytextarea.appendTo(tablistcontainer), tablistcontainer.querySelectorAll(".website-title"))
	tablistcontainer: document.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot.getElementById("history-item-container");
```

however, the above method still requires restructuring when we move the branch
alternatively, we can define some weird new syntax

```js
tablist: document
	.getElementById("history-app")
	.shadowRoot
	.getElementById("synced-devices")
	.shadowRoot
	.getElementById("synced-device-list")
	.children[0]
	.shadowRoot
	.getElementById("history-item-container") --> tablistcontainer
	.querySelectorAll(".website-title")

mytextarea.appendTo(tablistcontainer);
```

this still is a little ugly because we have to convert it to vertical style

```js
document.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot.getElementById("history-item-container")(--> tablistcontainer).querySelectorAll(".website-title")

mytextarea.appendTo(tablistcontainer);
```

or...?

```js
tablist: document
	.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot
	.getElementById("history-item-container") --> tablistcontainer
	.querySelectorAll(".website-title")

mytextarea.appendTo(tablistcontainer);
```

this^^ would still require some restructuring, but not as much


### <Nodes> Represent Ideas

* one of the benefits of Arcana is that, because everything is just a collection of properties, it is really easy to jot down rough ideas
* ideas are just collections of more ideas
* no structure, no form, no rules
* imperative langs impose too many rules to be able to do sketches

### Metaprogramming Thoughts III

context: Metaprogramming Thoughts I and II

* in fact, in "Facets" I talked about how programming is oftentimes about viewing a program from different perspectives
* there are many different perspectives we've discussed so far
	* the core code
	* preview view
	* version control
* metaprogramming and facets are very similar
* viewing a program from different perspectives
* arcana's flexible unrestricted syntax allows for ideas of any type or form to be written down
* metaprogramming allows these ideas to be interpreted and turned into actual programs

### IDE Smart Selection

* when you start selecting, it will try to guess what you are selecting, and make a generalization
  * eg if you are selecting variables that contain the word "elem", it will notice, and give you the option to select the rest
  * this is faster and more intuitive than trying to use regex

### Equality and State Variables

so after this whole singleton set shit

x: (a: 10, b: 20, 30)
x: 30 // true

it's comparing internal values

but what about if we are making objects
no internal value to compare
so compares references

y: (a: 10, b: 20)
z: (tag: 'hi', y)

y != z

sometimes we want to add tags or modify objects, but maintain equality
other times we want to create a new object, that we can modify independently of the old object

difference between modifying a node, and creating a new node

### Auto Binding - User Defined vs Dynamically Generated Properties

* objects can have two types of properties: user-defined and dynamically generated

```js
snippet = "aurora borealis!? At this time of year," ... "entirely within your kitchen!?"; // a long paragraph of words
HOVERTEXT_MAX_CHARS = 50; // maximum number of characters allowed in hover text

myObject = {
	title: "wordbank",
	description: "hashset of all words in a given snippet"
};
for (word in snippet.split(" ")) {
	myObject[word] = true
}

// an html element for the object
// `description` should be inherited from myObject
// however, imagine if `snippet` somehow contained the text "HOVERTEXT_MAX_CHARS"
// we don't want that to override 
myObjectDiv = myObject(
		hovertext: description.substring(0, HOVERTEXT_MAX_CHARS)
	);
```

* switch-style properties are dynamic, should they be excluded too?

### Sets in Sets

how do we interpret

```js
foo:
	x: 10
	(y: 20) // parenthesized expression

```

* does the parenthesized expression inside `foo` evaluate to an anonymous value?
* or does it evaluate to a property of foo?
* is there a difference?

* what about

```js
foo: (a, b, c), (d)
	e
	(f, g)
```


* how would we make a list of two lists?

### Overriding Anonymous Values

if we had something like

```js
sum:
	a + b

diff: sum(
	a-b
	); // this is passed into sum as an argument

// so how do we override sum's output?
```

### Clone Scopes and Time Complexity

* vishvanand brought up a good point about the time complexity of my weird scoping rules

```js
fn1: a+1

fn2: fn1(
	a+2
)
fn3: fn2(
	a+3
)
fn4: fn3(
	a+4
)

....

fnN: fnN-1(
	a+N
)
```

time complexity of this?

every time we add a value, it has to check it across all source scopes

perhaps we can memoize?
	every time we clone an object, memoize which arguments are unbound
	we can use the previous clone's memoization to figure it out
	only takes O(1)

what if overriding properties only changed last scope? but then do we still have access to source properties? I think so?

### The Comma Operater

* parenthesis is not used for sets

* have to use `{}` for sets
* each object indented block also counts as a set
* but if you have multiple parenthesis, they all combine

* can we do `x: (a: 'hello', b: 'world')` for inline objects?


* use spread operator to combine lists
* `combined: ...firstList, ...secondList`

* comma operator takes last precedence
* so `if...else if...else` and other operators combine first

### Clone Scopes and Property Access

you can access parent scope properties?
	scope as inputs (find where previously talked about)
	inputs are local variables (talked about in onenote? maybe also in notes.mdown? maybe in implicit inputs section?)
	...
	but don't we already have this capability through inheritance? `Student: Person(...)`
	`foo1, foo2: foo1(...), foo3: foo2(...)`, `bar1, bar2: bar1(...), bar3: bar2(...)`, `foobar: ...?`
	no, I don't think you can implement our weird multiple-inheritance scoping with our inheritance model


scope as inputs
	when you call/clone, it actually re-defines the module in the argument scope? wrapping?
	that way, `foo()` defines it in an empty scope, and `foo(this)` wraps it in this scope

foo(a: 10, b: 20)

these are bound first? last?

source scope { argument scope { callee } }

argument scope { source scope { callee } }

* if bound first, then overrides scope binding
* if bound last, then property overriding doesn't work

scopes are just syntactic sugar for passing everything as an input

this way overriding is actually just overshadowing
also a consequence of being able to access parent properties


wait but overriding is different from overshadowing
in overriding, dependents are affected
in overshadowing, dependents are unaffected
if you are just overshadowing, then accessing parent dependents doesn't make sense does it?



metaprogrammings means that programs have to be able to be defined programatically (including the way scopes work)

so perhaps we need to be able to clone within a given scope, like `foo(this)` or `foo.applyScope(this)` was supposed to do

actually, we can define modules programmatically without it

```js
clone: obj =>
	clonedObj:
		for prop in obj.allProperties:
			(prop): clone(obj[prop])
;
```





perhaps we can programmatically define scopes using other methods...
override the accessor?
or can we achieve the same effect by defining our properties correctly?
how do streams work?
mixins? (if multiple inheritance, define a precedence order)




cloning isn't the same as creating an argument scope, or wrapping an argument scope
you are actually copying the original module, including the bindings
if you change an input, it affects the output, because the new output is bound to the new input
if you don't clone the bindings, then you aren't really creating new outputs


an alternative method would be to ask for outputs, which are dynamically created when needed
for example, if we had something like

```js
sum: a+b

myObject:
	a: 10, b: 20

out: myObject[sum] // dynamically call sum() from myObject's scope

```

it is like attaching an output
this is similar to functional, where everything is call-by-need
define a bunch of functions in global scope
each function has a single output
then when you need an output, you call the corresponding function, with the correct arguments


in Arcana, we are currently doing the opposite
we are providing the outputs beforehand, preparing them
in the background, it works using call-by-need though
but we are still explicitly declaring the outputs beforehand, even if we might not need them
kind of like APIs

this style allows us to "name" things, because names can be different based on context

```js
square: x => x*x

Person:
	BMI: weight/(square(height)) // weight in kg, height in m

Joe: Person
	weight: 50 // kg
	height: 1.6 // m

output: Joe.BMI

// makes a lot more sense than

output: (50/1.6*1.6) // call by need, functional style

```


man for some reason I just can't shake the feeling that clone scoping just makes sense
if argument and parameter names don't match, just pass them in
if parameter names are named correctly, then you don't need to
if everything in the world can be modeled in a graph of relationships, then we can't use a hierarchal model to name everything
the functional model, of putting functions in global scope and then attaching them to objects, makes sense
from the example in "Clone Scopes", it's not like `candy` should defined within a `Joe` or `Person` namespace, but `diabetic` clearly means the same thing in both contexts


we can define everything in global scope, which would be like functional style, and can accurately represent graph-like structures
it works like a whitelist: we explicitly declare bindings and arguments

when we use nested scopes, we are creating an approximation of the graph model, using a tree hierarchy
as we go further and further into nested scopes, more and more variables enter the scope
becomes a "blacklist" model, where we have a ton of variables in scope, and they are all included by default

note that it's still possible to create a graph-like structure using the tree model
we just start with the tree, and add back-pointers until we get the desired graph
in many cases this is the most intuitive way

however, in terms of _automatic_ bindings, the tree model just doesn't suffice
if we rely too much on the tree model, we will end up with code duplication, and trap ourselves with too many variables in scope

the tree model does two things:
	create a hierarchy
	set up a system of automatic bindings

we technically don't need the tree model to create a hierarchy
so the automatic bindings is the main reason
so clone scoping makes sense
if you don't want automatic bindings, don't use the tree model?

if we look inside an object cloned inside a tree hierarchy, and it says it's missing the `diabetic` value, even though `diabetic` is clearly defined in the tree...


perhaps this is more based on the IDE
allow us to write a function in global scope while in local scope
like a `create new global variable` context menu option or something


what if we wanted `Joe` to buy a candy for a different person?
then `Joe.diabetic` shouldn't affect the candy
but the candy also shouldn't be created in Joe either right?
maybe created in a Vending Machine or something
but then again, Joe's personal candy would be created in the Vending Machine too
the request for the candy is created in Joe, with Joe's personal dietary restrictions
but then again, the request for his friend's candy is also created in Joe...
we're just changing layers of abstraction, but we have the same problem



creating things in other scopes breaks encapsulation
so perhaps calling from other scopes, `fn.apply(otherObject)`, doesn't make much sense
note that this would be using flag-watcher model, asking `otherObject` to create the object for us
so it could return undefined if we want


should we allow automatic bindings across arbitrary structures, not just tree structures?
allow inheritances along a graph structure?
we already kind of have this with overriding
this is a different sort of inheritance?
`foo: bar()` vs `foo: bar: ...`
first example, foo is bar's child, foo inherits from bar
second example, bar inherits from foo

I realize now that i've been mixing up scoping and inheritance
discussed in the later section "Scopes vs Inheritance"

### Advanced Useless Machine II

```js
lastReset = now() // time of last reset switch

function resetTimer() {
	lastReset = now()
	setTimeout(_ -> 
		if (now() - lastReset >= 20) // if it wasn't reset during the timeout, then close the box
			closebox()
	, 20)
}

// called when switch is turned on
function onswitch(index) {
	if (box.closed)
		openbox()

	closeSwitch(index)
	resetTimer()
}
```


```js
box:
	open, closed // states
	state: if (current_time .within(10).after (last_opened) ) open else closed

last_opened: Math.max(...switches.map(x => x.on_opened.lastCall)) // when the most recent switch was opened
_switch:
	on_opened: do // note that i'm assuming multiple calls are queued up, like in javascript
		close()
;
```


```js
simple_useless_machine:
	box:
		open, close
	switch:
		close, // action for closing the switch (implementation hidden)
		on_opened:
			box.open()
			close()
			box.close()

advanced_useless_machine: simple_useless_machine (

	@metaprogramming(foo)
	for switch in switches:
		when switch.opened:
			switch.close()

	foo:
		queue:

			
		box:

		switch:
			on_closed:
			on_opened:

);
```


### State Variables Syntax Brainstorm

* use `:=` to re-define a state variable?

```js
foo:
	counter := 10 // initial declaration
	for keypresses:
		counter++
```

* note that the initial declaration uses the re-definition operator `:=`
* maybe we can consider it a re-definition, and that `counter` is an implicit symbol (because not declared in scope)?
* nah, because if it already is in scope, we want to shadow it with our own `counter` variable...

* also, remember that we can only re-assign once per scope?








nested scopes are allowed in functional

```js
function createCounter() {
	x = 0;
  return function () {
  	return x++;
  }
}

function fibonacci(n) {
	// a: last fib number
	// b: second to last fib number
	// i: index
	return (function helper(a, b, i) {
		return i < n ? helper(a+b, a, i+1) : a+b
	})(0,1,0)
}
```


how does metaprogramming work in javascript? can you even create functions with local variables?
how would I make the `createCounter` function programmatically?






### Scopes vs Inheritance

scoping and inheritance both involve dynamic binding

```js
//inheritance
Person: name, age, occupation
	greeting: "hi I'm " + name + ", I'm a " + occupation
Student: Person
	occupation: "student"
	studentId: name+major+graduationYear

// scoping
Person2:
	name, age, occupation
	greeting: "hi I'm " + name + ", I'm a " + occupation
	Student2:
		occupation: "student"
		studentId: name+major+graduationYear
```

* inheritance is uses a tree structure (every child can only have one parent)
* scoping traditionally uses a tree structure...	
	* but our clone scoping model uses a weirder structure

* property access is traditionally different
* `Student.age` exists, `Student2.age` doesn't exist

* inheritance overrides variables, scoping shadows variables
* inheritance can affect parent properties, scoping can't
	* eg `greeting` is affected in `Student`, but not `Student2`
	* `greeting` is also not accessible from `Student2`

* `Student` is a global variable
* `Student2` is not

### Scopes as Namespaces

* notice that in the previous section "Scopes vs Inheritance", `Student` was a global variable while `Student2` was not
* perhaps scopes are just used to separate variables into namespaces
* having everything as a global variable will just make names super messy

* but namespaces are like pointers: `Books->Fiction->Fantasy->HarryPotter`
* but pointers don't have to form tree structures
* what's wrong with `Books->YoungAdult->HarryPotter`

* namespaces and variables should form a graph structure
* there are multiple routes to each variable
* every program starts at a certain namespace
* and can move around, navigate through the namespace graph
* in the above example, the program is starting at the `Books` namespace

* Cono (common knowledge) is the entire graph of all human knowledge
* every program just starts at a node in the graph, and works it's way around

* but if namespaces form a graph structure, then how does scoping work?
* usually, scopes form tree structures, and the number of variables in scope increases as you get into deeper scopes

* but in fact, if you have feedback in your scopes

```js
foo:
	bar:
		zed: foo
```

* we can "expand" `zed: foo` infinitely

```js
foo:
  bar:
    zed:
      bar:
        zed:
          bar:
            zed:
              ...
_
```

* but then, does `zed` see all variables inside `bar`? does `bar` see all variables inside `zed`?

* tree-structured hierarchal scoping is just an approximation
* this relates back to the section "Scope as a Search Function"
* we could feasibly have an AI do dynamic scoping for us, and recommend to us bindings and such
* but for now, maybe hierarchal scoping is the next best thing we have

### Cloning and Feedback

* note that it's possible to create an infinite cloning loop

		foo: foo()

* this is possible in any language though

		function fn() { fn(); }

* this is different from reference feedback

		foo: foo

* because reference feedback is structural, doesn't involve creating anything new

### Cloning - The Dynamic Component

* in the previous section, "Clone Feedback", I had a huge realization

* cloning is the only "dynamic" component of the language

* everything else is based on references and structures
* but cloning actually creates something new, creates new information
* that's why feedback is only an issue when it involves cloning
* if there's no cloning, then it's a purely structural feedback, and can evaluate in finite time

* how does this fit into our previous conclusion, about how feedback is about evaluation models
	* see the section "Feedback - Evaluation Models/Systems"
* I guess you could consider `foo: foo()` a structure, if you consider the cloning process a "module"
* but something still has to evaluate it
* something has to generate new information
* I guess in my previous conclusion, I was ignoring the fact that evaluation models need to be implemented in Arcana too

* if you think about it, the state machine of a Turing machine is a finite structure as well
* so it's really just the evaluation of that state machine that can cause infinite behavior
* the only thing that allows programs to halt is the "end condition" of the Turing machine
* but because our language is persistent, there is no "end condition", everything is being continuously evaluated

### Scoping Feedback

* is it possible to create feedback using our dynamic scoping rules?

* with clone scoping

```js
foo:
	x
	bar:
		x: 10
		zed: foo() // implicit scope inheritance

foo:
	bar: foo.withScope(this) // explicit scope passing
;
```

* this isn't so much of a dynamic scoping problem, as it is a clone feedback problem
* we are actually creating new instances of `foo` every time, (along with a new scope), so there actually is no feedback in the scopes

* however, if we factor in state variables

```js
foo:
	x
	bar:
		x: 10

onClick:
	foo.bar.zed := foo.withScope(this)
;
```

* does this introduce feedback?
* I mean it seems totally plausible that we could create a feedback system with dynamic scopes
* involving dynamic bindings that go in a loop
* but is that really preventable? Or is that something the programmer just has to be wary of

### Sub-Properties

* objects can be properties (see section "Objects as Property Keys II")
* that means property keys can have properties!
* tags in tags in tags! (yo dawg I heard you like tags...)

* this can be useful for things like state variables
* if you create a state variable indexed by time:

```
onKeyPress(event):
	stateVar[event.time] := event.key
```

* `event.time` resolves to a number, that can be used to order all states of the state variable
* however, let's say somebody messes with the state variable:

```
for (i from 0 to 10):
	stateVar[i] := "hehe"
```

* these new states have a numerical index as well
* however, they don't actually represent "time"
* our system can detect that the index types don't match because `event.time` actually has the `type: time` tag

```
event.time:
	1530358922792 // example time (milliseconds since 1970)
	type: "time"
```

* oftentimes the index or property name doesn't give us enough information
* we can use sub-properties to learn more

### Property Access for Mixed Modules

property access for "mixed" modules?
does it return properties of the module, or the outputs?
or are they combined? and if so, which takes precedence?
	it feels kinda similar to inheritance
	but it isn't the same

maybe inherits the same way as state variables?
have a `self` or `this` variable that references the latest value?
* kinda like how javascript uses `this` inside objects/classes for object properties
	* `this.x = 10` sets the object member, `x = 10` sets a local variable
* we can do something similar for state variables
	* `{x: 10 {x : 20} }` just shadows the variables, they don't affect eachother
	* `{ this.x: 10 { this.x: 20 } }` now the variables affect eachother, they refer to the same `x` variable


two ways of dealing with "mixed" modules
	1. a special operator to access values
	2. inheritance (output inherits module properties, or vice versa)
	3. go back to transformations model

the transformations model kinda makes sense:
	take a piece of the network graph
	clone it
	and then return only the last nodes in the cloned graph, the "output nodes"
	we don't want to just clone the last node, but we also don't want to return the entire graph

let's try the inheritance model...
if the hanging value is supposed to represent the "output" of the module, then it should take precedence for inheritance

so hanging values inherit all properties from the module?
but recall that hanging values are just properties without names
but if hanging values inherit properties from the module, then shouldn't every other property do the same?
in diagram-based syntax, we had a special accessor for accessing the entire object

perhaps we don't need transformations
in the diagram-syntax, every variable pointed to an object, that's it
just use accessor pattern
every node represents a bunch of references
a group of transformations
you clone the entire group
and the next part pulls out whatever it needs

### Back to Regular Nodes and Modules

* perhaps we should just go back to the old model of just properties
* no return statements or default outputs
* cloning just clones the entire module, and returns the entire module
* basically, the idea of "Nodes" that we established way back in the section "Node datatype"
	* and in our diagram syntax

* how would this work with `map`?
* imagine `map()` with only properties (no returns, unbound variables or hanging values)
* you give `map` a module to create for each item, `fn`
* for each list item, `map` clones `fn` and calls it with the item: `fn(item)`
* from each of these clones, `map` pulls out the result of the module, `fn(item).result`

* so it would look something like this:

```js
nums: [1 3 4]
square: x => result: x*x
// note: a wrapper to make `square` compatible with `map`
squareMap: item => result: square(x: item).result // basically just changes the property names to ones recognized by `map`

list:
	map: fn =>
		mapResult: []
		for list: item, index =>
			mapResult[index]: fn(item: item).result

nums.map(squareMap).mapResult = [1 9 16]
```

* this works fine
* it only looks ugly because we have these kinda arbitrary names, `x`, `item`, `result` and `mapResult` that we have to keep track of
* we have to create the intermediate function `squareMap` just to make `square` compatible with `map`

* anonymous keys and values takes care of this annoyance
* basically, just remove the property names (just like we can do in the diagram-based syntax)
* we are not introducing any new mechanics, we are just changing the names of properties

```js
nums: [1 3 4]
square: x => x*x

list:
	map: fn =>
		mapResult: []
		for list: item, index =>
			(mapResult[index]): fn(item) // notice the object deconstruction syntax used to pull the anonymous value out of fn(item)
		mapResult // output mapResult as an anonymous value

nums.map(squareMap)... = [1 9 16]; // notice the anonymous value access, using the spread operator
```

* notice that we don't need the wrapper function `squareMap` anymore

the only way to pull hanging values out is to use unbound symbols
many ways to do so:
	deconstruction, like `(a, b): mNode`
	[] or . operator without a name (so something like `mNode[]`, or `mNode.`)
	spread operator, eg `fn(mNode...)` or `mNode... = (1, 2)`

* it's interesting because this all makes a lot more sense in diagrams
* much more intuitive
* see "Nodes.one" for more
* and it's basically how my diagram-based syntax has worked since the beginning
* so i think the text-based language confused me a little bit
* we are just so used to the idea of "functions"
	* you call a function, it runs the body, and then returns a result
* it's weird to imagine a language where calling a function returns the entire function
* but that's exactly how nodes work
* and using value access everywhere is just something you have to get used to, I guess

### The Map Function and the Evolution of Nodes (so far)

note that, one of the MAJOR examples I was considering for the past like 2 months or so is the `map` example
(even though I barely mention it in the notes)
It was one of the main reasons why I thought transformations made sense
because it felt ugly to use accessor pattern directly, like `map(fn(...).result)`
	in fact, I realized that accessor pattern doesn't even work here, because `map` would be cloning `result`, not the module
or to have `map` have some specified property that it pulled from, eg `map: fn => result: fn(item).result, ...`
so it seemed like `map` needed to:
	1. be given a module
	2. call the module with the list item as an argument
	3. use the result from the module, _not the module itself_
that last part was important, because without transformations, it would return the module itself
	* eg, if you wanted to square a list of numbers, `list.map(square)` would return a list of `square` modules, not a list of numbers
this is why transformations made sense
	when cloning the module, it automatically returned the result, not the module itself
however, I had to come up with special rules about cloning transformations
	cloning would override the intermediate scope, not the result
and I realized that these special rules broke associativity
	* see section "Cloning and The Associative Property"
at the same time, I was finalizing my ideas about unbound keys and hanging values
to solve the associativity problem, I tried to create a concept of "mixed modules"
	* see section "Mixed Modules"
* modules could be viewed as both a module or a value
* modules represented a history of values and operations
* however, this ultimately created conflicts, especially when it came to accessing properties
	* should property access take from the module or the value? or both?
	* should the value inherit properties from the module?
* I realized I had to go back to the diagram syntax, go back to thinking about nodes as just nodes in a graph
* cloning just clones a section of the graph
* `map` has to be given which section of the graph to clone
* it's up to `map` to handle the result
	* it could pull out a designated property, like `result` or something
	* but it could also just return the entire cloned module
	* and there's nothing the user can do about it
	* if `list.map(square)` returns a list of `square` modules, not a list of numbers, then that's just how `map` is implemented
* makes the most sense for `map` to extract a value from the module
* luckily, we can leverage hanging values so we don't have to use a designated name like `result`
* note that this means, that if we want `map` to return the entire cloned module, we have to specify that in our given function
	* eg: `square: x => result: x*x, this`
	* notice that the hanging value is `this`, which refers to the entire `square` module, so that's what `map` will return

### Default Outputs

* before, I considered the idea that modules with no outputs should by default "return" the entire module
	* see section "Transformations vs Objects"
	* I talked about how "regular modules are a special kind of transformation, whose output is the module itself"
* this also sort of made sense with the idea of mixed modules
* however, in the context of nodes, this doesn't make sense anymore
* outputs are just hanging values, properties with no name
* if there are no such values, then there are no "outputs"
* makes a lot of sense with object deconstruction

```js
(output1, output2):
	a: 10
	b: 20
	a+b
```

* in the above example, `output2` is undefined
* likewise:

```js
(output1):
	a: 10
	b: 20
```

* in this example, `output1` should be undefined
* wouldn't make sense for `output1` to suddenly store the entire object

### Ordered Lists and Indexed Output Access

* I think if we want to access hanging values individually
* we should use numerical indices
* but then our sets are basically arrays now... :/
* Nylo treats it as ordered lists as well

### Mixed Nodes Revisited

everything is a mixed node
up to the operators how to treat it
we can make it so inputs to functions automatically spread
because thats how it looks in diagrams
we can add an operator if we want to access 

```js
sum: a, b => a+b
Person: name, age, id =>
;
x: sum(10, 20)
Bob: Person(name: "Bob", age: 30, id: 0x31da3);
```

* notice that if you wanted to use `x` stores an object, `( a: 10, b: 20, 30 )`
* if you wanted to get the value `30`, you would have to use `...x`
* or we could have declared `x: ...sum(10,20)`
* thing is, in this case, we would never really ever use `x` as an object
* so we would either have to use `...x` everywhere, or declare it with `...sum(10,20)`
* in fact, for most functions like `sum`, things that have an "output", you would rarely ever use it as an object

* the opposite is true for objects
* while `Bob` technically has an output value of `()` (an empty set), we would rarely ever use that

* so perhaps we can treat objects different depending on whether or not they have outputs
* treat them as either a "transformation" or an "object"
* because rarely are they used as both

* so whenever you use `x`, it pulls out the values
* best understood through diagrams
* usage vs cloning
* should be able to clone functions
* 

* or maybe () is like a general purpose "call", works differently for objects vs functions
* there is an explicit operator for cloning
* and an explicit operator for extraction (spread operator `...`)

* foo: sum() actually uses deconstruction
* if you want to be explicit, and return an object, there's an operator for that
* `...foo: sum()`
* wait...or you can just use cloning for that




* note that this is whether or not they have _declared_ outputs
* for something like this

```js
foo: cond =>
	if (cond): 10
```

* `foo` technically has no outputs if `cond` is false
* however, because we are declaring outputs, we are viewing `foo` as a function, not a module


Cloning should work the same
Usage could be different




### Diagram vs Text Based Syntax

* I realized a lot of the problems I was having was because it's hard to translate my diagram syntax to text
* a lot of the stuff giving me trouble are things that work pretty intuitively in the diagram syntax

* for example, in diagrams, it's easy to see whether or not a variable refers to the module itself, or an output
	* just look at if the variable name is at the top of the module, or at the end of an output

* we can also easily pick specific outputs, without numerical indices, using something like

```
    ___________
   |____foo____|
     ' | ' | |
```

* this extracts the 2nd, 4th, and 5th output

### Internal Unwrapping

* why can't we use the `internal_value` model we explored for numbers and `sum`?

```js
sum: (a b) => internal_value: a.internal_value + b.internal_value
```

* this makes it so we can take results directly and sum them again, like `sum(sum(1,2), sum(3,4))`
* if we use unbound keys and values, we won't need the arbitrary `internal_value` keyword

```js
sum: (a b) => ...a + ...b
;
```

* so now we can use `sum` like normal
* however, writing the `sum` function is still weird
* we have to keep in mind this unwrapping
* for example, if we wanted to write a function that multiplies two matrices

```js
matprod: (a b) =>
	Matrix
		map a.rows: row =>
			map b.cols: col =>
				dot(row, col)
;

x: Matrix(...);
xx: matprod(x,x); // this works (but doesn't return a Matrix, rather, an object containing a Matrix)
xxx: matprod( matprod(x, x) , matprod(x, x) ); // this won't work
```

* we can't use the results of `matprod` as arguments for another call to `matprod`
* we have to remember to use `...a` and `...b` if I want to support this recursive behavior

```js
Matrix.multiply: (a b) =>
	Matrix
		map ...a.rows: row =>
			map ...b.cols: col =>
				dot(row, col)
;
```

* so this unwrapping behavior, we can either do it outside the function, or inside the function
* but it needs to happen somewhere


* unless we make it the default behavior for modules with hanging values?
* a hanging value is like a return statement
* when you clone the function, it returns the hanging value as output?

### Object Deconstruction

object deconstruction is just key-value auto-binding!
`firstVal: foo()`, `firstVal, secondVal: foo()`

maybe property access should access the original object properties, not properties of the values
`myfunction(foo(10,20).bar)` means we don't want to auto-bind key-values anymore
but this only works for direct clone access
if we do `x: foo(10,20), x.bar`, `x` is already the deconstructed first argument

wait but if things get autodeconstructed, `foo(x(), y())` what if `x()` has multiple outputs...shouldn't it treat it as a set? or an object?
same with `foo: x(), y()`, this shouldn't be equivalent to `foo: ...x(), ...y()` right?

### Currying and Returns

* so I was talking about veggero about cloning and currying
* because recall that I thought calling broke associativity (see section "Cloning and The Associative Property")
* aka `x = x() = x()()`
* however, Nylo supports currying, even though it seems to have function calling
* so I talked with veggero about it
* and he seemed to have confirmed my suspicions
* basically, the way Nylo works, is that even though it has the concept of functions, it waits for it to be "complete" before return the outputs
* for example, take `sum: a, b -> a+b`
* `sum(10)` would return a clone of the sum function
* but `sum(10)(20)` would return the output, `30`

* the problem is, a distributed dataflow language like Arcana, shouldn't have the concept of "incomplete" vs "complete" functions
* if we are extracting the output of a node, it doesn't matter whether its incomplete or complete
* an output is an output
* you never know when an input might go `undefined` temporarily
* that shouldn't suddenly make the function become "incomplete" and break everything after it

### Imperative Langs and Multiple Outputs

* note that, in normal imperative langs:
	* if you return one item, its just the item
	* if you return multiple, it has to be wrapped in a set
* eg `() => 10` vs `() => [10, 20]`
* so even in imperative langs, there's a distinction between single and multiple return
* thought that's sort of because imperative langs are only used to one output
* but maybe one output is just so much more common than any other case
* and text-based syntax works best with one output

### Function vs Class - Dynamic Evaluation and Forced Coercion

* maybe we can combine the ideas of nylo and arcana
* it makes sense to kinda differentiate between classes and functions
* but at the same time, they should have the same structure (set of keys + values)
* in nylo, you specify a function using `->`
	* in nylo, there are some other differences between a function/class, but that's not too relevant here
* instead, maybe we can have dynamic evaluation of function vs class
* by default, if there is only one static output, it is a function, otherwise its a class
* you can force it to be evaluated as a class using `{}`
	* groups it into one object
* you can force it to be evaluated as a function using `...`
	* extracts and spreads the values

* so to defining a function would look like:

```js
{sum}: a b => a+b
;
```

* which basically is
	1. creating a module, with a single output
	2. binding the name to the module, not the output

* while this makes it a little uglier, and means we have to use special notation to define functions
* it's already common in languages to have different syntax for function vs class
* and we had to do that in nylo's version anyways, using the arrow operator for functions

* it also makes sense if you think about object destructuring
* recall that something like this

```js
a, b, c : (x: 10, y: 20, x+y, x*y, x/y)
```

* binds the values of the right hand side to `a`, `b`, and `c`
* it follows that this:

```js
a: (x: 10, y: 20, x+y, x*y, x/y)
```

* is just binding the first value

### Function/Class Syntax Exploration

* exploring some other syntaxes for defining functions:

```js
{sum}: a b => a+b // looks like the modules in diagram language

sum(): a b => a+b // looks like imperative function declarations

sum...: a b => a+b // sorta makes sense b/c the spread operator is on the other side, so instead of deconstruction, its like object _construction_

;
```

* what about when passing functions?

```js
list.map(a b => a+b)
;
```

* hmm, now it's being evaluated as a function, so won't it end up passing it's values to `map`, instead of the entire function?
* you would have to do `list.map({a b => a+b})`

* the thing is, there is no reason to define a module unless you want it treated as a module
* if we just wanted to pass the values to `map`, we could have just done `list.map(a+b)`
* even if we wanted some intermediate variables, we could have defined them in the outer scope
	* eg: `c: a+b, list.map(c)`

* same with definitions, there is no reason we'd define a module from scratch unless we wanted it treated as a module

```js
sum: a b => a+b
;
```

* in the above example, it get's evaluated as a function, so it passes its values to `sum`
* but then we could have just done `sum: a+b`

* the only time we might want it evaluated as a function is if we were cloning a function

```js
add10: a => sum(b: 10)
;
```

so it seems like it really does all come back to cloning vs calling after all

### Different Syntax for Calling vs Cloning

* actually the solution seems simple enough
* just use different syntax for cloning vs calling!
* `foo(...)` for calling, and `foo{...}` for cloning
* remember that calling is just shorthand for cloning + spreading (`...foo`)
* but now, we can actually use `foo()` as shorthand for spreading, `...foo`

* this also makes sense for bracketed expressions
	* discussed previously in section "Singleton Sets"
* in `(3+1)`, we are "calling" the blank scope with `4` as an argument, so `4` gets returned
* if we want to create a set with `4` in it, we have to clone the blank scope, like `{3+1}`

* note that operators, like `+` and `==`, are shorthand for function _calls_, not cloning

* notice that, as discussed in the previous section "Function/Class Syntax Exploration", there's still not much point to using parenthesis when calling/cloning
* eg `foo(10, (a b => a+b))`
* because it just evaluates to the values
* you have to explicitely create it as a module if you want one, `foo(10, {a b => a+b})`

* I have honestly no idea why it took me so long to come up with this idea
* I guess I was just so obsessed with the idea that calling and cloning were the same thing
* and to be able to use the `()` bracket for everything

### Implicit Parenthesis III

* so now that we have different brackets for calling and cloning, what does that mean for indentation and implicit parenthesis?
* makes the most sense for the implicit bracket to be `{}`

```js
Student: Person
	occupation: "student"

// is the same as

Student: Person {
	occupation: "student"
}
_
```

* note that the first line is still interpreted as a value or "expression"
* because no indentation yet

but then how would we do implicit brackets for calls?

```js
// this doesn't work because it's cloning sum{}
x: sum
	a: 10, b: 20

// this doesn't work either, it's returning the output of sum, and cloning that
x: sum()
	a: 10, b: 20

// this works (because the implied brackets takes precedence over the spread operator), but it's ugly
x: ...sum
	a: 10, b: 20
```

* note that we could also switch implied brackets to be () instead of {}
* because there's no reason to clone without arguments,
	* empty braces `{}` can be used for capturing the subsequent indented block as arguments

### Calling and Map

* note that, now, if you pass an object to `map`, it will "call" the object, and return the output (aka nothing, b/c objects have no output)

* this actually makes sense
* `list.map` takes a function
* so if you give it an object, with no return
* makes sense that it will extract nothing and return nothing
* likewise, if you have multiple outputs, it will append all of them
* if you want the multiple outputs to be appended as a set, you have to output the object itself
	* just like how in regular imperative langs, you have to wrap the outputs in a set

### Dynamic Scoping vs Inheritance - App Creation Example

* if we were making an app, where should we store the data?
* we could make it a web-app, which automatically makes it session based
* we could make it a user-app, which makes it persistent
* depending on where we "attach" the data, determines its lifetime
* this is sorta like dynamic scoping
* if we declare the app in the "web" context, it inherits all the methods and properties of web apps
* if we declare it in "user" context, it inherits all methods and properties of user apps
* though we could do it a more conventional way using inheritance
* just extend the prototype `WebApp` or `UserApp`, and it naturally comes with all the appropriate methods/properties
* so what's the difference?





### Summary of Ideas Explored for Nodes

ideas explored so far:
	returns and arrow operator
	dynamic interpretation of function vs class
		based on usage (mixed module)
		based on number of outputs
	different syntax for function vs class
		use {} to force evaluation as a class
		use ... to force evaluation as a function
	different syntax for calling vs cloning

### Values are Lists

* I decided to treat hanging values as list values, not set values, like how Nylo does it
* this means that hanging values are ordered now
* one benefit is we can now reference values by index
* another benefit is we can use `()` to define lists
* one last, huge benefit, is we can now use `[]` for defining modules, and get rid of the ugly `{}` notation
	* jk we can't actually do that
	* because then, is `foo[x: 10]` cloning `foo`, or accessing a property of `foo` (whose key is `x: 10`)?* 

* in addition, index makes a bit more sense now
* if we do `[10, 20, 30]`, it works like python's multidimensional array access, and is equivalent to `[10][20][30]`
* notice that this wouldn't be possible if it were unordered* 

* we will just use `key: true` for set values, like in every other language (python, javascript)

* maybe we can also use periods for creating sets
* `foo: a. b. c.` is the same as `foo: ( a: true, b: true, c: true )`

### Lists and Statements

* now that hanging values are ordered...
* this actually works well with state variables now
* because we can insert ordered statements directly into the object, and treat them as list values
	* eg `x++` and `y := 20` and `foo.push('hi')`
* note that most statements and variable modifications have no returned output
* so even though they're treated as list values and "executed", they won't show up in the actual output

### Square Brackets without Target

* notice that `()`, `{}`, and `[]` are all operators that
	1. have a target object
	2. take an object as input (source object)
* which is why they all use brackets (whereas other operators like `+` don't need it)
* however, remember that the idea of using `(x: 10)` without a target object is kinda like calling/extending a "blank slate"
	* as mentioned in the section "Implied Parenthesis" and "Implied Parenthesis II"
* thus, shouldn't `[]` without a target object also do something?

* in fact, it makes sense for it to do something
* access properties in the current scope!
* obviously we can access properties just using their name
	* eg `foo: a+b` will access properties `a` and `b` in the scope
* but if we want to use dynamic keys or object keys, we can use `[]`
	* eg `foo[a+b]` or `foo[type: number]`
* note that we can also do `this[a+b]`

* but does `this` and `[]` use the scope or the current object, as the source?
* this will affect whether or not it can access parent scopes or inherited properties




### Square Brackets without Source

* perhaps `[]` should be for keys

source-less []: retrieve values without properties? retrieve all keys?




### Clone Scopes

* because we have different syntax for cloning vs calling, we can actually leverage this for clone scopes
* cloning inherits the current scope, calling does not
* this actually makes a lot of sense, because inheriting scope doesn't really make sense for calling, but it does for cloning

* also, if we want to call and inherit scope, just do `fn{}(...)`

* also, if we want to clone without inheriting scope, just do `{fn(...)}`

* this gets kinda ugly with indentation

```js
// how to call with indentation?

// cloning without inheriting scope (blank-slate cloning):

foo: { bar(
	x: 10
)}
_
```

maybe we can use capture blocks (discussed later in section "Capture Blocks")

### Calling and Cloning - Edge Cases

* so how does object destructuring work now?

```js
a: 10 // is a equal to {10} or 10?
b: 
	10 // is b equal to {10} or 10?
c: 10
	20 // what is c?
d: (x: 10) // what happens here? is d = {x : 10}? is the line evaluate, and since no outputs, d = null? or a syntax error?

a, b: {10} // what happens here? does it get destructured into a: 10, b: null?
a, b: 10 // what happens here? does 10 somehow get destructured?

;
```

### Capture Blocks

* the idea of capture blocks, is to "capture" the next indented block as arguments
* for example, something like 

```js
foo: ()
	x: 10
	x*x + 30
```

* would be shorthand for this:

```js
foo: (
	x: 10
	x*x + 30
)
```

* let's us get rid of those pesky dangling closing brackets
* you could do the same for square brackets:

```js
[]
	x: 10
```

* and even though you don't need it for objects (because of implied brackets), it makes nested objects look better

```js
foo:
	{}
		x: 10
		y: 20
	{}
		bar: 'hello'
```

* problem is, it doesn't quite work for function calls

```js
foo: sum() // looks like capturing block, but it actually is extracting sum() and then cloning the result
	a: 10
	b: 20
```

* perhaps we can make this^^  work by having capture blocks take priority
* aka, first the parenthesis+capture block is evaluated, and then used as a call to `sum`
* so if we wanted to do the reverse, and first call `sum` and then treat the block as cloning, we would have to do

```js
foo: sum(){}
	tag: "this is attached to the result of sum()"
```

* we have the same confusion for brackets

```js
foo: sum[]
	x: 10
```

* is this^^ retrieving the keys of sum (which is what `sum[]` does), and then cloning them?
* or is it a capture block for an object key?

* honestly, the original order made more sense, `sum()` already looks like it's calling `sum` with no arguments
* to invert the order for capture blocks is unintuitive

### Capture Blocks II

* alternatively, we can also have special notation for capture blocks

```js
foo(...) // nice but uses a lot of characters
	x: 10
foo( ) // whitespace matters? but only for empty braces?
	x: 10
foo(_) // ugly, 
	x: 10
foo(): // doesn't this conflict with dynamic keys? shouldn't `:` be reserved for binding?
	x: 10
foo(…): // ellipses character looks more compact than triple dot. Automatic conversion by IDE? But then you can't use normal text editors
	x: 10 // oerperhaps make it so ... and … are both recognized the same

```

* I think the ellipses looks the best actually
* so here is what capture blocks will look like

```js
(…)
	10, 20, 30

[…]
	x: 10

foo:
	{…}
		x: 10
		y: 20
	{} // note that we can still use this, or even omit it entirely, due to rules for cloning and implicit braces
		bar: 'hello'
```

### Brackets Trinity

* the three brackets of power:

* [] is for keys
* () is for values
* {} is for nodes/groups

* it's not actually that perfectly symmetric but close enough
* I kinda came up with a language that only uses one bracket
* in the next section, "1Bracket: an experimental language"

### 1Bracket: an experimental language

* only one bracket: `()`
* all properties have to have names (so there's actually no difference between calling and cloning)
* if a module is given a value as an argument, treats it as a key, returns corresponding value
* if a module is given properties as an argument, clones module while overriding given properties
* if a module is given both values and properties, then it clones the module, and returns the corresponding values

* note that this allows us to use implied parenthesis for everything (no need for capture blocks)
* however, we will also probably have a lot of arbitrary names like `result` and `mapResult`
	* see section "Back to Regular Nodes and Modules" for why

### `For` Keyword

* so Nylo has the `for` keyword for map operations, which is pretty nice
* I've been using the keywords `reduce`, `map`, and `filter`, but those are kinda ugly terms
	* I'm actually not sure how Nylo handles reductions actually
* recall that in my diagram language, I had the "fan-out" syntax for reduction and map
* I think I can work that into the `for` syntax

```js
list: { 1 2 3 4 5 }
result: for item in list:
	item*item // any values are appended to the final list, like a map operation
	if (item % 2) 'x'+item // we can use conditionals for filter operations
	sum: item+prev.sum // use properties to do reductions. `prev` refers to previous states
	product: item*prev.sum // this syntax makes it easy to define reductions that pass multiple variables

result = { 1 4 'x2' 9 16 'x4' 25 }
```

### Indented Expression

* normally indented blocks are evaluated as object/nodes
* because of implied `{}`
* but sometimes you just want to move an expression to another line
* you can actually do something like this

```js
foo:
	list => ...
		for x in list:
			x*x
```
* without the `...`, the block under the `=>` would be viewed as an object, not an expression
	* the implied `{}` would make it look like `list => { for x in list: x*x }`
* but with the `...`, it now looks like `list => ...{ for x in list: x*x }`
* turning the indented block into an expression
* and we didn't even need to introduce new syntax!

### Dynamic Keys vs Conditionals

* be careful of the difference between dynamic keys and conditionals

```js
foo:
	(cond): 10 // dynamic key
	if (cond): 10 // conditional

```

* the first evaluates to a property, with a dynamic key
* if `cond` evaluates to `true`, then it becomes `true: 10`
* on the other hand, if conditionals evaluate to true, the inner values spread into the outer block
* if `cond` evalutes to `true`, then `foo` evaluates to `{10}`

### Matchers

* the idea behind matcher functions
* 	you can provide functions as a key
		if the function returns true when passed the accessor input, then it accesses the property
	strings and ints are actually functions that return true when passed themselves?
* matchers have a conditonal, and a value
	* if the key passes the conditional, then the value is returned
* they are like dynamic properties
* for example, we could create an object that looks like `{ a b c a b c a b c... }` from the outside
* useful for streams

syntax exploration

```js
multipleOfThree: x -> x % 3 == 0

foo:
	(multipleOfThree): 'a'
	(!multipleOfThree):
		key % 3 + 1 == 0: 'b'
		else: 'c'

match key -> if even(key): key*2

match if even(key): key*2 // by default, the match function provides a `key` variable

[key]: if even(key) key*2 // alternative syntax?

```

-------------------------------

nice thing about accepting objects as keys
	you can implement your own hashing function
	(in nylo, it used his hashing function)
	but what if you wanted to make a custom one
	maybe like the method python uses for multidimensional arrays

error codes
	everything is a node
	so even `undefined` can have tags

`self` vs `here`, scope vs inheritance (for brackets without a target)

arguments from different places (without cloning or currying)?
	split up module definitions?

```js
foo:
	x: 10
foo:
	y: 20
```

or perhaps we have to use state variables for this, and each new definition is actually a modification

how to make default variable names?
	eg, for reduce, if not given a variable name, automatically uses item
	`reduce(list, {item -> item*2}`, but if given a variable name, uses that, and frees up "item", `for list: x -> x*2`
	or perhaps, you just have to deal with `item` in the namespace
	or maybe there's a way so, when defining the function, you can either choose to inherit the namespace (dynamic scoping)
	or you can choose to define all your own variable names


shouldn't arrows automatically imply an object? so we don't have to keep doing stuff like `map({x -> x*x})`, and just do `map(x -> x*x)`
