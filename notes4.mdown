### Random Syntax Stuff

* i forgot when I wrote these down, so some of this stuff might be outdated, but this was just syntax exploration

```js
set:
	10
	20
	30

(a, b, c) = set() // object deconstruction

sum: // a, b   <-- implicit inputs, generated by the IDE
	tag: 'hello'
	a+b

sum(
	a: 10,
	b: 20
)

Person:
	name: 'bob'


Student: Person
	occupation: 'student'

//------------------------------------------------------

outer:
	a: 10
	inner: // b
		a+b

Bob:
	name: 'bob'
	id: 21943
	age: 20

	mStudentId: studentId()
	onlineAlias: onlineAlias()



// -----------------------------------------

list
	reduce
		acc, fn
		for item in list
			acc.next: fn(acc, item)

mList: [1, 2, 3, 4]
mList.reduce(0, (acc, item, => acc+item) )
mList.reduce(0, acc+item ) // because acc and item are unbound in this scope, it's up to reduce's scope to provide values for them


Student: Person.with
	age: 22
	occupation: undefined
```


### Arrow Operator to indicate Inputs

* instead of using the arrow operator to indicate outputs, maybe we can use it to indicate inputs

```js
foo: a, b, => // inputs/symbols
	x: "hello world"
	a+b // output

```

* recall that, back when `=>` was used for outputs, it forced us to group all our outputs onto one line/group at the end
* it actually makes more sense to use `=>` instead for inputs
* inputs are just variable names, so it's easy to group them all at the top, often on one line
* outputs can be long expressions, so forcing them on one line is annoying
* also, sometimes you might want some outputs in the middle, instead of all of them at the end

* a cool side effect of this is that, now the arrow operator works pretty much like in every other language

```js
// javascript code:
var myFn = (x, y) => x+y;
var squared = [1,2,3].map(x => x*x);

//arcana
myFn: x, y => x+y
squared: [1 2 3].map(x => x*x)
;
```

### Deeply Nested Outputs and State Variables

context: Carrying Out Deeply Nested Outputs

use state variables

```js
foo:
	x // a state variable
	a_bunch:
		of_nested:
			scopes:
				x := 20
```

### Branching II

context: Branching

recall that we were trying to find an easy to add a branch in the middle of a flow
the ugly way, that required an entire restructuring, was as follows

```js
var tablistcontainer = document.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot.getElementById("history-item-container")
tablistcontainer.appendChild(mytextarea)
var tablist = tablistcontainer.querySelectorAll(".website-title");
```

* we discussed how much easier this is in diagram-based languages
* where you can just draw connections

* text-based languages make it hard
* we could still sort of achieve this:

```js
// both values in the tuple have unbound `tablistcontainer`, which is then defined in the arguments module
// recall from the section "Implied Parenthesis" that indented blocks are implicitly treated as function arguments
(mytextarea.appendTo(tablistcontainer), tablistcontainer.querySelectorAll(".website-title"))
	tablistcontainer: document.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot.getElementById("history-item-container");
```

however, the above method still requires restructuring when we move the branch
alternatively, we can define some weird new syntax

```js
tablist: document
	.getElementById("history-app")
	.shadowRoot
	.getElementById("synced-devices")
	.shadowRoot
	.getElementById("synced-device-list")
	.children[0]
	.shadowRoot
	.getElementById("history-item-container") --> tablistcontainer
	.querySelectorAll(".website-title")

mytextarea.appendTo(tablistcontainer);
```

this still is a little ugly because we have to convert it to vertical style

```js
document.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot.getElementById("history-item-container")(--> tablistcontainer).querySelectorAll(".website-title")

mytextarea.appendTo(tablistcontainer);
```

or...?

```js
tablist: document
	.getElementById("history-app").shadowRoot.getElementById("synced-devices").shadowRoot.getElementById("synced-device-list").children[0].shadowRoot
	.getElementById("history-item-container") --> tablistcontainer
	.querySelectorAll(".website-title")

mytextarea.appendTo(tablistcontainer);
```

this^^ would still require some restructuring, but not as much


### <Nodes> Represent Ideas

* one of the benefits of Arcana is that, because everything is just a collection of properties, it is really easy to jot down rough ideas
* ideas are just collections of more ideas
* no structure, no form, no rules
* imperative langs impose too many rules to be able to do sketches

### Metaprogramming Thoughts III

context: Metaprogramming Thoughts I and II

* in fact, in "Facets" I talked about how programming is oftentimes about viewing a program from different perspectives
* there are many different perspectives we've discussed so far
	* the core code
	* preview view
	* version control
* metaprogramming and facets are very similar
* viewing a program from different perspectives
* arcana's flexible unrestricted syntax allows for ideas of any type or form to be written down
* metaprogramming allows these ideas to be interpreted and turned into actual programs

### IDE Smart Selection

* when you start selecting, it will try to guess what you are selecting, and make a generalization
  * eg if you are selecting variables that contain the word "elem", it will notice, and give you the option to select the rest
  * this is faster and more intuitive than trying to use regex

### Equality and State Variables

so after this whole singleton set shit

x: (a: 10, b: 20, 30)
x: 30 // true

it's comparing internal values

but what about if we are making objects
no internal value to compare
so compares references

y: (a: 10, b: 20)
z: (tag: 'hi', y)

y != z

sometimes we want to add tags or modify objects, but maintain equality
other times we want to create a new object, that we can modify independently of the old object

difference between modifying a node, and creating a new node

### Auto Binding - User Defined vs Dynamically Generated Properties

* objects can have two types of properties: user-defined and dynamically generated

```js
snippet = "aurora borealis!? At this time of year," ... "entirely within your kitchen!?"; // a long paragraph of words
HOVERTEXT_MAX_CHARS = 50; // maximum number of characters allowed in hover text

myObject = {
	title: "wordbank",
	description: "hashset of all words in a given snippet"
};
for (word in snippet.split(" ")) {
	myObject[word] = true
}

// an html element for the object
// `description` should be inherited from myObject
// however, imagine if `snippet` somehow contained the text "HOVERTEXT_MAX_CHARS"
// we don't want that to override 
myObjectDiv = myObject(
		hovertext: description.substring(0, HOVERTEXT_MAX_CHARS)
	);
```

* switch-style properties are dynamic, should they be excluded too?

### Sets in Sets

how do we interpret

```js
foo:
	x: 10
	(y: 20) // parenthesized expression

```

* does the parenthesized expression inside `foo` evaluate to an anonymous value?
* or does it evaluate to a property of foo?
* is there a difference?

* what about

```js
foo: (a, b, c), (d)
	e
	(f, g)
```


* how would we make a list of two lists?

### Overriding Anonymous Values

if we had something like

```js
sum:
	a + b

diff: sum(
	a-b
	); // this is passed into sum as an argument

// so how do we override sum's output?
```

### Clone Scopes and Time Complexity

* vishvanand brought up a good point about the time complexity of my weird scoping rules

```js
fn1: a+1

fn2: fn1(
	a+2
)
fn3: fn2(
	a+3
)
fn4: fn3(
	a+4
)

....

fnN: fnN-1(
	a+N
)
```

time complexity of this?

every time we add a value, it has to check it across all source scopes

perhaps we can memoize?
	every time we clone an object, memoize which arguments are unbound
	we can use the previous clone's memoization to figure it out
	only takes O(1)

what if overriding properties only changed last scope? but then do we still have access to source properties? I think so?

### The Comma Operater

* parenthesis is not used for sets

* have to use `{}` for sets
* each object indented block also counts as a set
* but if you have multiple parenthesis, they all combine

* can we do `x: (a: 'hello', b: 'world')` for inline objects?


* use spread operator to combine lists
* `combined: ...firstList, ...secondList`

* comma operator takes last precedence
* so `if...else if...else` and other operators combine first

### Clone Scopes and Property Access

you can access parent scope properties?
	scope as inputs (find where previously talked about)
	inputs are local variables (talked about in onenote? maybe also in notes.mdown? maybe in implicit inputs section?)
	...
	but don't we already have this capability through inheritance? `Student: Person(...)`
	`foo1, foo2: foo1(...), foo3: foo2(...)`, `bar1, bar2: bar1(...), bar3: bar2(...)`, `foobar: ...?`
	no, I don't think you can implement our weird multiple-inheritance scoping with our inheritance model


scope as inputs
	when you call/clone, it actually re-defines the module in the argument scope? wrapping?
	that way, `foo()` defines it in an empty scope, and `foo(this)` wraps it in this scope

foo(a: 10, b: 20)

these are bound first? last?

source scope { argument scope { callee } }

argument scope { source scope { callee } }

* if bound first, then overrides scope binding
* if bound last, then property overriding doesn't work

scopes are just syntactic sugar for passing everything as an input

this way overriding is actually just overshadowing
also a consequence of being able to access parent properties


wait but overriding is different from overshadowing
in overriding, dependents are affected
in overshadowing, dependents are unaffected
if you are just overshadowing, then accessing parent dependents doesn't make sense does it?



metaprogrammings means that programs have to be able to be defined programatically (including the way scopes work)

so perhaps we need to be able to clone within a given scope, like `foo(this)` or `foo.applyScope(this)` was supposed to do

actually, we can define modules programmatically without it

```js
clone: obj =>
	clonedObj:
		for prop in obj.allProperties:
			(prop): clone(obj[prop])
;
```





perhaps we can programmatically define scopes using other methods...
override the accessor?
or can we achieve the same effect by defining our properties correctly?
how do streams work?
mixins? (if multiple inheritance, define a precedence order)




cloning isn't the same as creating an argument scope, or wrapping an argument scope
you are actually copying the original module, including the bindings
if you change an input, it affects the output, because the new output is bound to the new input
if you don't clone the bindings, then you aren't really creating new outputs


an alternative method would be to ask for outputs, which are dynamically created when needed
for example, if we had something like

```js
sum: a+b

myObject:
	a: 10, b: 20

out: myObject[sum] // dynamically call sum() from myObject's scope

```

it is like attaching an output
this is similar to functional, where everything is call-by-need
define a bunch of functions in global scope
each function has a single output
then when you need an output, you call the corresponding function, with the correct arguments


in Arcana, we are currently doing the opposite
we are providing the outputs beforehand, preparing them
in the background, it works using call-by-need though
but we are still explicitly declaring the outputs beforehand, even if we might not need them
kind of like APIs

this style allows us to "name" things, because names can be different based on context

```js
square: x => x*x

Person:
	BMI: weight/(square(height)) // weight in kg, height in m

Joe: Person
	weight: 50 // kg
	height: 1.6 // m

output: Joe.BMI

// makes a lot more sense than

output: (50/1.6*1.6) // call by need, functional style

```


man for some reason I just can't shake the feeling that clone scoping just makes sense
if argument and parameter names don't match, just pass them in
if parameter names are named correctly, then you don't need to
if everything in the world can be modeled in a graph of relationships, then we can't use a hierarchal model to name everything
the functional model, of putting functions in global scope and then attaching them to objects, makes sense
from the example in "Clone Scopes", it's not like `candy` should defined within a `Joe` or `Person` namespace, but `diabetic` clearly means the same thing in both contexts


we can define everything in global scope, which would be like functional style, and can accurately represent graph-like structures
it works like a whitelist: we explicitly declare bindings and arguments

when we use nested scopes, we are creating an approximation of the graph model, using a tree hierarchy
as we go further and further into nested scopes, more and more variables enter the scope
becomes a "blacklist" model, where we have a ton of variables in scope, and they are all included by default

note that it's still possible to create a graph-like structure using the tree model
we just start with the tree, and add back-pointers until we get the desired graph
in many cases this is the most intuitive way

however, in terms of _automatic_ bindings, the tree model just doesn't suffice
if we rely too much on the tree model, we will end up with code duplication, and trap ourselves with too many variables in scope

the tree model does two things:
	create a hierarchy
	set up a system of automatic bindings

we technically don't need the tree model to create a hierarchy
so the automatic bindings is the main reason
so clone scoping makes sense
if you don't want automatic bindings, don't use the tree model?

if we look inside an object cloned inside a tree hierarchy, and it says it's missing the `diabetic` value, even though `diabetic` is clearly defined in the tree...


perhaps this is more based on the IDE
allow us to write a function in global scope while in local scope
like a `create new global variable` context menu option or something


what if we wanted `Joe` to buy a candy for a different person?
then `Joe.diabetic` shouldn't affect the candy
but the candy also shouldn't be created in Joe either right?
maybe created in a Vending Machine or something
but then again, Joe's personal candy would be created in the Vending Machine too
the request for the candy is created in Joe, with Joe's personal dietary restrictions
but then again, the request for his friend's candy is also created in Joe...
we're just changing layers of abstraction, but we have the same problem



creating things in other scopes breaks encapsulation
so perhaps calling from other scopes, `fn.apply(otherObject)`, doesn't make much sense
note that this would be using flag-watcher model, asking `otherObject` to create the object for us
so it could return undefined if we want


should we allow automatic bindings across arbitrary structures, not just tree structures?
allow inheritances along a graph structure?
we already kind of have this with overriding
this is a different sort of inheritance?
`foo: bar()` vs `foo: bar: ...`
first example, foo is bar's child, foo inherits from bar
second example, bar inherits from foo

I realize now that i've been mixing up scoping and inheritance
discussed in the later section "Scopes vs Inheritance"

### Advanced Useless Machine II

```js
lastReset = now() // time of last reset switch

function resetTimer() {
	lastReset = now()
	setTimeout(_ -> 
		if (now() - lastReset >= 20) // if it wasn't reset during the timeout, then close the box
			closebox()
	, 20)
}

// called when switch is turned on
function onswitch(index) {
	if (box.closed)
		openbox()

	closeSwitch(index)
	resetTimer()
}
```


```js
box:
	open, closed // states
	state: if (current_time .within(10).after (last_opened) ) open else closed

last_opened: Math.max(...switches.map(x => x.on_opened.lastCall)) // when the most recent switch was opened
_switch:
	on_opened: do // note that i'm assuming multiple calls are queued up, like in javascript
		close()
;
```


```js
simple_useless_machine:
	box:
		open, close
	switch:
		close, // action for closing the switch (implementation hidden)
		on_opened:
			box.open()
			close()
			box.close()

advanced_useless_machine: simple_useless_machine (

	@metaprogramming(foo)
	for switch in switches:
		when switch.opened:
			switch.close()

	foo:
		queue:

			
		box:

		switch:
			on_closed:
			on_opened:

);
```


### State Variables Syntax Brainstorm

* use `:=` to re-define a state variable?

```js
foo:
	counter := 10 // initial declaration
	for keypresses:
		counter++
```

* note that the initial declaration uses the re-definition operator `:=`
* maybe we can consider it a re-definition, and that `counter` is an implicit symbol (because not declared in scope)?
* nah, because if it already is in scope, we want to shadow it with our own `counter` variable...

* also, remember that we can only re-assign once per scope?








nested scopes are allowed in functional

```js
function createCounter() {
	x = 0;
  return function () {
  	return x++;
  }
}

function fibonacci(n) {
	// a: last fib number
	// b: second to last fib number
	// i: index
	return (function helper(a, b, i) {
		return i < n ? helper(a+b, a, i+1) : a+b
	})(0,1,0)
}
```


how does metaprogramming work in javascript? can you even create functions with local variables?
how would I make the `createCounter` function programmatically?






### Scopes vs Inheritance

scoping and inheritance both involve dynamic binding

```js
//inheritance
Person: name, age, occupation
	greeting: "hi I'm " + name + ", I'm a " + occupation
Student: Person
	occupation: "student"
	studentId: name+major+graduationYear

// scoping
Person2:
	name, age, occupation
	greeting: "hi I'm " + name + ", I'm a " + occupation
	Student2:
		occupation: "student"
		studentId: name+major+graduationYear
```

* inheritance is uses a tree structure (every child can only have one parent)
* scoping traditionally uses a tree structure...	
	* but our clone scoping model uses a weirder structure

* property access is traditionally different
* `Student.age` exists, `Student2.age` doesn't exist

* inheritance overrides variables, scoping shadows variables
* inheritance can affect parent properties, scoping can't
	* eg `greeting` is affected in `Student`, but not `Student2`
	* `greeting` is also not accessible from `Student2`

* `Student` is a global variable
* `Student2` is not

### Scopes as Namespaces

* notice that in the previous section "Scopes vs Inheritance", `Student` was a global variable while `Student2` was not
* perhaps scopes are just used to separate variables into namespaces
* having everything as a global variable will just make names super messy

* but namespaces are like pointers: `Books->Fiction->Fantasy->HarryPotter`
* but pointers don't have to form tree structures
* what's wrong with `Books->YoungAdult->HarryPotter`

* namespaces and variables should form a graph structure
* there are multiple routes to each variable
* every program starts at a certain namespace
* and can move around, navigate through the namespace graph
* in the above example, the program is starting at the `Books` namespace

* Cono (common knowledge) is the entire graph of all human knowledge
* every program just starts at a node in the graph, and works it's way around

* but if namespaces form a graph structure, then how does scoping work?
* usually, scopes form tree structures, and the number of variables in scope increases as you get into deeper scopes

* but in fact, if you have feedback in your scopes

```js
foo:
	bar:
		zed: foo
```

* we can "expand" `zed: foo` infinitely

```js
foo:
  bar:
    zed:
      bar:
        zed:
          bar:
            zed:
              ...
_
```

* but then, does `zed` see all variables inside `bar`? does `bar` see all variables inside `zed`?

* tree-structured hierarchal scoping is just an approximation
* this relates back to the section "Scope as a Search Function"
* we could feasibly have an AI do dynamic scoping for us, and recommend to us bindings and such
* but for now, maybe hierarchal scoping is the next best thing we have

### Cloning and Feedback

* note that it's possible to create an infinite cloning loop

		foo: foo()

* this is possible in any language though

		function fn() { fn(); }

* this is different from reference feedback

		foo: foo

* because reference feedback is structural, doesn't involve creating anything new

### Cloning - The Dynamic Component

* in the previous section, "Clone Feedback", I had a huge realization

* cloning is the only "dynamic" component of the language

* everything else is based on references and structures
* but cloning actually creates something new, creates new information
* that's why feedback is only an issue when it involves cloning
* if there's no cloning, then it's a purely structural feedback, and can evaluate in finite time

* how does this fit into our previous conclusion, about how feedback is about evaluation models
	* see the section "Feedback - Evaluation Models/Systems"
* I guess you could consider `foo: foo()` a structure, if you consider the cloning process a "module"
* but something still has to evaluate it
* something has to generate new information
* I guess in my previous conclusion, I was ignoring the fact that evaluation models need to be implemented in Arcana too

* if you think about it, the state machine of a Turing machine is a finite structure as well
* so it's really just the evaluation of that state machine that can cause infinite behavior
* the only thing that allows programs to halt is the "end condition" of the Turing machine
* but because our language is persistent, there is no "end condition", everything is being continuously evaluated

### Scoping Feedback

* is it possible to create feedback using our dynamic scoping rules?

* with clone scoping

```js
foo:
	x
	bar:
		x: 10
		zed: foo() // implicit scope inheritance

foo:
	bar: foo.withScope(this) // explicit scope passing
;
```

* this isn't so much of a dynamic scoping problem, as it is a clone feedback problem
* we are actually creating new instances of `foo` every time, (along with a new scope), so there actually is no feedback in the scopes

* however, if we factor in state variables

```js
foo:
	x
	bar:
		x: 10

onClick:
	foo.bar.zed := foo.withScope(this)
;
```

* does this introduce feedback?
* I mean it seems totally plausible that we could create a feedback system with dynamic scopes
* involving dynamic bindings that go in a loop
* but is that really preventable? Or is that something the programmer just has to be wary of

### Sub-Properties

* objects can be properties (see section "Objects as Property Keys II")
* that means property keys can have properties!
* tags in tags in tags! (yo dawg I heard you like tags...)

* this can be useful for things like state variables
* if you create a state variable indexed by time:

```
onKeyPress(event):
	stateVar[event.time] := event.key
```

* `event.time` resolves to a number, that can be used to order all states of the state variable
* however, let's say somebody messes with the state variable:

```
for (i from 0 to 10):
	stateVar[i] := "hehe"
```

* these new states have a numerical index as well
* however, they don't actually represent "time"
* our system can detect that the index types don't match because `event.time` actually has the `type: time` tag

```
event.time:
	1530358922792 // example time (milliseconds since 1970)
	type: "time"
```

* oftentimes the index or property name doesn't give us enough information
* we can use sub-properties to learn more

### Property Access for Mixed Modules

property access for "mixed" modules?
does it return properties of the module, or the outputs?
or are they combined? and if so, which takes precedence?
	it feels kinda similar to inheritance
	but it isn't the same

maybe inherits the same way as state variables?
have a `self` or `this` variable that references the latest value?
* kinda like how javascript uses `this` inside objects/classes for object properties
	* `this.x = 10` sets the object member, `x = 10` sets a local variable
* we can do something similar for state variables
	* `{x: 10 {x : 20} }` just shadows the variables, they don't affect eachother
	* `{ this.x: 10 { this.x: 20 } }` now the variables affect eachother, they refer to the same `x` variable


two ways of dealing with "mixed" modules
	1. a special operator to access values
	2. inheritance (output inherits module properties, or vice versa)
	3. go back to transformations model

the transformations model kinda makes sense:
	take a piece of the network graph
	clone it
	and then return only the last nodes in the cloned graph, the "output nodes"
	we don't want to just clone the last node, but we also don't want to return the entire graph

let's try the inheritance model...
if the hanging value is supposed to represent the "output" of the module, then it should take precedence for inheritance

so hanging values inherit all properties from the module?
but recall that hanging values are just properties without names
but if hanging values inherit properties from the module, then shouldn't every other property do the same?
in diagram-based syntax, we had a special accessor for accessing the entire object

perhaps we don't need transformations
in the diagram-syntax, every variable pointed to an object, that's it
just use accessor pattern
every node represents a bunch of references
a group of transformations
you clone the entire group
and the next part pulls out whatever it needs

### Back to Regular Nodes and Modules

* perhaps we should just go back to the old model of just properties
* no return statements or default outputs
* cloning just clones the entire module, and returns the entire module
* basically, the idea of "Nodes" that we established way back in the section "Node datatype"
	* and in our diagram syntax

* how would this work with `map`?
* imagine `map()` with only properties (no returns, unbound variables or hanging values)
* you give `map` a module to create for each item, `fn`
* for each list item, `map` clones `fn` and calls it with the item: `fn(item)`
* from each of these clones, `map` pulls out the result of the module, `fn(item).result`

* so it would look something like this:

```js
nums: [1 3 4]
square: x => result: x*x
// note: a wrapper to make `square` compatible with `map`
squareMap: item => result: square(x: item).result // basically just changes the property names to ones recognized by `map`

list:
	map: fn =>
		mapResult: []
		for list: item, index =>
			mapResult[index]: fn(item: item).result

nums.map(squareMap).mapResult = [1 9 16]
```

* this works fine
* it only looks ugly because we have these kinda arbitrary names, `x`, `item`, `result` and `mapResult` that we have to keep track of
* we have to create the intermediate function `squareMap` just to make `square` compatible with `map`

* anonymous keys and values takes care of this annoyance
* basically, just remove the property names (just like we can do in the diagram-based syntax)
* we are not introducing any new mechanics, we are just changing the names of properties

```js
nums: [1 3 4]
square: x => x*x

list:
	map: fn =>
		mapResult: []
		for list: item, index =>
			(mapResult[index]): fn(item) // notice the object deconstruction syntax used to pull the anonymous value out of fn(item)
		mapResult // output mapResult as an anonymous value

nums.map(squareMap)... = [1 9 16]; // notice the anonymous value access, using the spread operator
```

* notice that we don't need the wrapper function `squareMap` anymore

the only way to pull hanging values out is to use unbound symbols
many ways to do so:
	deconstruction, like `(a, b): mNode`
	[] or . operator without a name (so something like `mNode[]`, or `mNode.`)
	spread operator, eg `fn(mNode...)` or `mNode... = (1, 2)`

* it's interesting because this all makes a lot more sense in diagrams
* much more intuitive
* see "Nodes.one" for more
* and it's basically how my diagram-based syntax has worked since the beginning
* so i think the text-based language confused me a little bit
* we are just so used to the idea of "functions"
	* you call a function, it runs the body, and then returns a result
* it's weird to imagine a language where calling a function returns the entire function
* but that's exactly how nodes work
* and using value access everywhere is just something you have to get used to, I guess

### The Evolution of Nodes, A Retrospective Journey

note that, one of the MAJOR examples I was considering for the past like 2 months or so is the `map` example
(even though I barely mention it in the notes)
It was one of the main reasons why I thought transformations made sense
because it felt ugly to use accessor pattern directly, like `map(fn(...).result)`
	in fact, I realized that accessor pattern doesn't even work here, because `map` would be cloning `result`, not the module
or to have `map` have some specified property that it pulled from, eg `map: fn => result: fn(item).result, ...`
so it seemed like `map` needed to:
	1. be given a module
	2. call the module with the list item as an argument
	3. use the result from the module, _not the module itself_
that last part was important, because without transformations, it would return the module itself
	* eg, if you wanted to square a list of numbers, `list.map(square)` would return a list of `square` modules, not a list of numbers
this is why transformations made sense
	when cloning the module, it automatically returned the result, not the module itself
however, I had to come up with special rules about cloning transformations
	cloning would override the intermediate scope, not the result
and I realized that these special rules broke associativity
	* see section "Cloning and The Associative Property"
at the same time, I was finalizing my ideas about unbound keys and hanging values
to solve the associativity problem, I tried to create a concept of "mixed modules"
	* see section "Mixed Modules"
* modules could be viewed as both a module or a value
* modules represented a history of values and operations
* however, this ultimately created conflicts, especially when it came to accessing properties
	* should property access take from the module or the value? or both?
	* should the value inherit properties from the module?
* I realized I had to go back to the diagram syntax, go back to thinking about nodes as just nodes in a graph
* cloning just clones a section of the graph
* `map` has to be given which section of the graph to clone
* it's up to `map` to handle the result
	* it could pull out a designated property, like `result` or something
	* but it could also just return the entire cloned module
	* and there's nothing the user can do about it
	* if `list.map(square)` returns a list of `square` modules, not a list of numbers, then that's just how `map` is implemented
* makes the most sense for `map` to extract a value from the module
* luckily, we can leverage hanging values so we don't have to use a designated name like `result`
* note that this means, that if we want `map` to return the entire cloned module, we have to specify that in our given function
	* eg: `square: x => result: x*x, this`
	* notice that the hanging value is `this`, which refers to the entire `square` module, so that's what `map` will return

### Default Outputs

* before, I considered the idea that modules with no outputs should by default "return" the entire module
	* see section "Transformations vs Objects"
	* I talked about how "regular modules are a special kind of transformation, whose output is the module itself"
* this also sort of made sense with the idea of mixed modules
* however, in the context of nodes, this doesn't make sense anymore
* outputs are just hanging values, properties with no name
* if there are no such values, then there are no "outputs"
* makes a lot of sense with object deconstruction

```js
(output1, output2):
	a: 10
	b: 20
	a+b
```

* in the above example, `output2` is undefined
* likewise:

```js
(output1):
	a: 10
	b: 20
```

* in this example, `output1` should be undefined
* wouldn't make sense for `output1` to suddenly store the entire object
